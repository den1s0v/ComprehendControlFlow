<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ctrlstrct_test API documentation</title>
<meta name="description" content="Test determining of errors can be made by a student
during step-by-step construction of given algorithm&#39;s execution trace." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ctrlstrct_test</code></h1>
</header>
<section id="section-intro">
<p>Test determining of errors can be made by a student
during step-by-step construction of given algorithm's execution trace.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># encoding: utf-8
# ctrlstrct_test.py

&#34;&#34;&#34;
Test determining of errors can be made by a student
during step-by-step construction of given algorithm&#39;s execution trace.

&#34;&#34;&#34;

import atexit
import json
import os
from glob import glob
from pathlib import Path

import external_run
import trace_gen.styling
from ctrlstrct_run import process_algtraces
from onto_helpers import delete_ontology
from trace_gen.json2alg2tr import act_line_for_alg_element
from trace_gen.dict_helpers import get_ith_expr_value, find_by_keyval_in


def process_algorithm_and_trace_from_json(alg_tr: dict):
    &#34;&#34;&#34;
    Demonstration entry point.
    :param alg_tr: a dict with at least keys &#34;trace&#34;, &#34;algorithm&#34;
    :return: feedback{&#34;messages&#34;: [...], &#34;mistakes&#34;: [...]}
    &#34;&#34;&#34;
    feedback = {&#34;messages&#34;: []}

    # validate input alg_tr
    # {
    #     &#34;trace_name&#34;    : str,
    #     &#34;algorithm_name&#34;: str,
    #     &#34;trace&#34;         : list,
    #     &#34;algorithm&#34;     : dict,
    #     &#34;header_boolean_chain&#34; : list of bool,
    # }
    try:
        assert alg_tr, f&#34;Empty data&#34;
        assert type(alg_tr) == dict, f&#34;&#39;JSON data is not a dict!&#34;;
        key = &#34;trace_name&#34;
        t = str
        assert key in alg_tr, f&#34;Key &#39;{key}&#39; is missing&#34;
        assert type(alg_tr[key]) == t, f&#34;&#39;{key}&#39; -&gt; is not a {str(t)}&#34;
        key = &#34;algorithm_name&#34;
        t = str
        assert key in alg_tr, f&#34;Key &#39;{key}&#39; is missing&#34;
        assert type(alg_tr[key]) == t, f&#34;&#39;{key}&#39; -&gt; is not a {str(t)}&#34;
        key = &#34;trace&#34;
        t = list
        assert key in alg_tr, f&#34;Key &#39;{key}&#39; is missing&#34;
        assert type(alg_tr[key]) == t, f&#34;&#39;{key}&#39; -&gt; is not a {str(t)}&#34;
        key = &#34;algorithm&#34;
        t = dict
        assert key in alg_tr, f&#34;Key &#39;{key}&#39; is missing&#34;
        assert type(alg_tr[key]) == t, f&#34;&#39;{key}&#39; -&gt; is not a {str(t)}&#34;
    except AssertionError as e:
        feedback[&#34;messages&#34;] += [f&#34;JSON error: {str(e)}\n{alg_tr}&#34;]
        return feedback

    alg_trs = [alg_tr]

    if not alg_trs:
        feedback[&#34;messages&#34;] += [&#34;Nothing to process: no valid algorithm / trace found.&#34;]
        return feedback

    # call it
    mistakes, err_msg = process_algorithms_and_traces(alg_trs)

    if err_msg:
        feedback[&#34;messages&#34;] += [err_msg]
    else:
        feedback[&#34;messages&#34;] += [&#34;Processing of algorithm &amp; trace finished OK.&#34;]
        feedback[&#34;mistakes&#34;] = mistakes

    return feedback


def make_act_json(algorithm_json, algorithm_element_id: int, act_type: str, existing_trace_json,
                  user_language=None) -&gt; list:
    &#34;&#34;&#34;
    `act_type`: &#39;started&#39; or &#39;finished&#39; for complex, &#39;performed&#39; for simple statements.
    Returns full supplemented trace: list of dicts, each dict represents act object.
    (Returns string with error description if an exception occurred)
    &#34;&#34;&#34;
    # filter out incorrect acts (if any)
    existing_trace_json = existing_trace_json or ()
    existing_trace_list = [act for act in existing_trace_json if act[&#34;is_valid&#34;] == True]

    try:
        elem = algorithm_json[&#34;id2obj&#34;].get(algorithm_element_id,
                                            algorithm_json[&#34;id2obj&#34;].get(str(algorithm_element_id)))

        assert elem, f&#34;No element with id={algorithm_element_id} in given algorithm.&#34;

        max_id = max(a[&#39;id&#39;] for a in existing_trace_list) if existing_trace_list else 100 - 1

        result_acts = []
        # make line &#34;program began&#34; first
        if len(existing_trace_list) == 0 and elem[&#39;id&#39;] != algorithm_json[&#34;entry_point&#34;][&#39;id&#39;]:
            # создать строку &#34;program began&#34;
            act_text = act_line_for_alg_element(algorithm_json, phase=&#39;started&#39;,
                                                lang=user_language, )  # передаём сам корень алгоритма, так как его type==&#39;algorithm&#39;,
            max_id += 1
            html_tags = trace_gen.styling.prepare_tags_for_line(act_text)
            result_acts.append({
                &#39;executes&#39;: algorithm_json[&#34;entry_point&#34;][&#39;id&#39;],
                # ! а привязываем к глобальному коду (или функции main)
                &#39;name&#39;: algorithm_json[&#34;entry_point&#34;][&#39;name&#39;],
                &#39;phase&#39;: &#39;started&#39;,
                &#39;as_string&#39;: act_text,
                # &#39;as_tags&#39;: html_tags,
                &#39;as_html&#39;: trace_gen.styling.to_html(html_tags),
                &#39;id&#39;: max_id,
                &#39;n&#39;: 1,
                &#39;is_valid&#39;: True  # в начале трассы акт всегда такой
            })

        exec_time = 1 + len(
            [a for a in existing_trace_list if a[&#39;executes&#39;] == algorithm_element_id and a[&#39;phase&#39;] == act_type])

        expr_value = None
        if elem[&#39;type&#39;] == &#34;expr&#34; and act_type in (&#39;finished&#39;, &#39;performed&#39;):
            name = elem[&#39;name&#39;]
            expr_list = algorithm_json[&#39;expr_values&#39;].get(name, None)

            assert expr_list is not None, f&#34;No expression values provided for expression &#39;{name}&#39; in given algorithm.&#34;

            expr_value = get_ith_expr_value(expr_list, exec_time - 1)

            # assert expr_value is not None, f&#34;Not enough expression values provided for expression &#39;{name}&#39;: &#39;{expr_list}&#39; provided, # {exec_time} requested.&#34;
            if expr_value is None:
                expr_value = False
                print(f&#34;Info: use default value: {expr_value} for expression &#39;{name}&#39;.&#34;)

        act_text = act_line_for_alg_element(
            elem,
            phase=act_type,
            lang=user_language,
            expr_value=expr_value,
            use_exec_time=exec_time,
        )
        max_id += 1
        html_tags = trace_gen.styling.prepare_tags_for_line(act_text)
        act_json = {
            &#39;executes&#39;: elem[&#39;id&#39;],
            &#39;name&#39;: elem[&#39;name&#39;],
            &#39;phase&#39;: act_type,
            &#39;as_string&#39;: act_text,
            # &#39;as_tags&#39;: html_tags,
            &#39;as_html&#39;: trace_gen.styling.to_html(html_tags),
            &#39;id&#39;: max_id,
            &#39;n&#39;: exec_time,
            &#39;is_valid&#39;: None,  # пока нет информации о корректности такого акта
            # &#39;is_valid&#39;: True,  # debug !!
        }
        if expr_value is not None:
            act_json[&#39;value&#39;] = expr_value

        result_acts.append(act_json)

        return existing_trace_list + result_acts
    except Exception as e:
        # raise e
        return f&#34;Server error in make_act_json() - {type(e).__name__}:\n\t{str(e)}&#34;


def add_styling_to_trace(algorithm_json, trace_json, user_language=None, comment_style=None, add_tags=False) -&gt; list:
    &#34;&#34;&#34;Adds text line, tags and html form for each act in given trace and returns the same reference to the trace list.
    `comment_style`: {None | &#39;use&#39; | &#39;highlight&#39;}
    &#34;&#34;&#34;
    try:
        assert isinstance(trace_json, (list, tuple)), &#34;The trace was not correctly constructed: &#34; + str(trace_json)

        for act_dict in trace_json:

            algorithm_element_id = act_dict[&#39;executes&#39;]
            elem = algorithm_json[&#34;id2obj&#34;].get(algorithm_element_id,
                                                algorithm_json[&#34;id2obj&#34;].get(str(algorithm_element_id), None))

            assert elem, f&#34;No element with id={algorithm_element_id} in given algorithm.&#34;

            if elem[&#39;id&#39;] == algorithm_json[&#34;entry_point&#34;][&#39;id&#39;]:
                # to make &#34;program began&#34; line: pass the root
                elem = algorithm_json

            act_text = act_line_for_alg_element(
                elem,
                phase=act_dict[&#39;phase&#39;],
                lang=user_language,
                expr_value=act_dict.get(&#39;value&#39;, None),
                use_exec_time=int(act_dict[&#39;n&#39;]),
            )
            if &#39;comment&#39; in act_dict and act_dict[&#39;comment&#39;] and comment_style is not None:
                act_text += &#34;    // &#34; + act_dict[&#39;comment&#39;]

            html_tags = trace_gen.styling.prepare_tags_for_line(act_text)

            if &#39;comment&#39; in act_dict and act_dict[&#39;comment&#39;] and comment_style == &#39;highlight&#39;:
                html_tags = {
                    &#34;tag&#34;: &#34;span&#34;,
                    &#34;attributes&#34;: {&#34;class&#34;: [&#34;warning&#34;]},
                    &#34;content&#34;: html_tags
                }

            add_json = {
                &#39;as_string&#39;: act_text,
                &#39;as_html&#39;: trace_gen.styling.to_html(html_tags),
            }
            act_dict.update(add_json)
            if add_tags:
                add_json = {
                    &#39;as_tags&#39;: html_tags,
                }
                act_dict.update(add_json)

        return trace_json
    except Exception as e:
        # raise e
        return f&#34;Server error in add_styling_to_trace() - {type(e).__name__}:\n\t{str(e)}&#34;


def process_algorithms_and_traces(alg_trs_list: list, write_mistakes_to_acts=False) -&gt; (
        &#39;mistakes: list[str]&#39;, &#39;error_message: str or None&#39;):
    try:
        onto, mistakes = process_algtraces(alg_trs_list, verbose=0, mistakes_as_objects=False)

        if not mistakes and len(alg_trs_list) == 1:
            # try to find automatically polyfilled acts &amp; insert them into the trace
            # apply the simplest behaviour: skipped acts will be inserted to the previous-to-the-last position.
            if implicit_acts := list(onto.implicit_act.instances()):
                implicit_acts.sort(key=lambda a: a.id)
                acts_count = len(implicit_acts)
                print(acts_count, &#39;implicit_acts found, inserting them into trace.&#39;)

                algorithm = alg_trs_list[0][&#34;algorithm&#34;]
                # to be modified in-place (new acts will be inserted to prev. to the last)
                mutable_trace = alg_trs_list[0][&#34;trace&#34;]

                for imp_act in implicit_acts:
                    bound = imp_act.executes
                    assert bound
                    st = bound.boundary_of
                    assert st
                    algorithm_element_id = st.id
                    if onto.act_end in imp_act.is_a:
                        act_type = &#34;finished&#34;
                    elif onto.act_begin in imp_act.is_a:
                        act_type = &#34;started&#34;
                    else:
                        raise ValueError(&#34;implicit act has no begin/end type!: %s&#34; % imp_act)
                    appended_trace = make_act_json(algorithm_json=algorithm, algorithm_element_id=algorithm_element_id,
                                                  act_type=act_type, existing_trace_json=mutable_trace[:-1],
                                                  user_language=None)
                    assert len(appended_trace) &gt;= 2, appended_trace
                    mutable_trace.insert(-1, appended_trace[-1])
            # end for

            if finish_trace_acts := list(onto.finish_trace_act.instances()):
                # finish_trace_act exists =&gt; finish the trace.

                print(&#39;finish_trace_act found, closing the trace.&#39;)
                act = finish_trace_acts[0]

                algorithm = alg_trs_list[0][&#34;algorithm&#34;]
                # to be modified in-place (new acts will be inserted to prev. to the last)
                mutable_trace = alg_trs_list[0][&#34;trace&#34;]

                bound = act.executes
                assert bound
                end_of_trace_bound = bound.consequent[0]
                assert end_of_trace_bound
                st = end_of_trace_bound.boundary_of
                assert st

                algorithm_element_id = st.id
                act_type = &#34;finished&#34;

                appended_trace = make_act_json(algorithm_json=algorithm, algorithm_element_id=algorithm_element_id,
                                              act_type=act_type, existing_trace_json=mutable_trace[:],
                                              user_language=None)

                assert len(appended_trace) &gt;= 2, appended_trace
                new_last_line = appended_trace[-1]

                # создать строку &#34;program ended&#34;
                act_text = act_line_for_alg_element(algorithm, phase=&#39;finished&#39;,
                                                    lang=None, )  # передаём сам корень алгоритма, так как его type==&#39;algorithm&#39;,
                # обновить в строке трассы, т.к. по умолчанию генерируется &#39;следование global_code закончилось 1-й раз&#39;
                new_last_line[&#34;as_string&#34;] = act_text
                html_tags = trace_gen.styling.prepare_tags_for_line(act_text)
                new_last_line[&#39;as_html&#39;] = trace_gen.styling.to_html(html_tags)

                mutable_trace.append(new_last_line)
                ### print(&#34;+=+ inserted closing act:&#34;, new_last_line[&#34;as_string&#34;])

        delete_ontology(onto)

        if write_mistakes_to_acts and len(alg_trs_list) != 1:
            print(&#34;** Warning!: write_mistakes_to_acts is inapplicable when traces count =&#34;, len(alg_trs_list), &#34;(!=1)&#34;)
        if write_mistakes_to_acts and len(alg_trs_list) == 1:
            # ошибки нужны, и сейчас не режим тестирования
            trace = alg_trs_list[0][&#39;trace&#39;]
            for mistake in mistakes:
                act_id = mistake[&#34;id&#34;][0]
                for act_obj in list(find_by_keyval_in(&#34;id&#34;, act_id, trace)):
                    new_explanations = act_obj.get(&#34;explanations&#34;, []) + mistake[&#34;explanations&#34;]
                    act_obj[&#34;explanations&#34;] = sorted(set(new_explanations))
                    if not act_obj[&#34;explanations&#34;]:  # был пустой список - запишем хоть что-то
                        act_obj[&#34;explanations&#34;] = [&#34;Ошибка обнаружена, но вид ошибки не определён.&#34;]
                    act_obj[&#34;mistakes&#34;] = mistake
                    act_obj[&#34;is_valid&#34;] = False
                    if &#39;value&#39; in act_obj:
                        print(&#34; ***** Reset expr evaluation value.&#34;)
                        act_obj[&#34;value&#34;] = &#34;not evaluated&#34;
                        # del act_obj[&#34;value&#34;]
                        alg_data = alg_trs_list[0][&#39;algorithm&#39;]
                        # rewrite this act
                        add_styling_to_trace(alg_data, [act_obj])
                # break

            # Apply correctness mark to other acts:  act_obj[&#34;is_valid&#34;] = True
            for act_obj in trace:
                if act_obj[&#34;is_valid&#34;] is None:
                    act_obj[&#34;is_valid&#34;] = True

            # Признак окончания трассы
            # set act_obj[&#34;is_final&#34;] = True for end of the topmost statement
            top_stmts = set()
            for alg_obj in find_by_keyval_in(&#34;type&#34;, &#34;algorithm&#34;, alg_trs_list):
                top_stmts.add(alg_obj[&#34;entry_point&#34;][&#34;body&#34;][-1][&#34;id&#34;])
            assert top_stmts, top_stmts

            for act_obj in trace:
                if (act_obj[&#34;is_valid&#34;] == True
                        and act_obj[&#34;phase&#34;] in (&#39;finished&#39;, &#34;performed&#34;)
                        and act_obj[&#34;executes&#34;] in top_stmts):
                    act_obj[&#34;is_final&#34;] = True

        return mistakes, None
    except Exception as e:
        msg = &#34;Exception occured in process_algorithms_and_traces(): %s: %s&#34; % (str(type(e)), str(e))
        raise e
        print(msg)
        return [], msg


def run_tests(input_directory=&#34;../data/python/&#34;, output_directory=&#34;../results/&#34;):
    test_results = {}
    try:
        for file in glob(os.path.join(input_directory, &#39;*.json&#39;)):
            path = Path(file)
            print(&#34;processing test:&#34;, path.name)
            with open(path) as f:
                input_data = json.load(f)

            results = process_algorithm_and_trace_from_json(input_data)

            test_results[path.stem] = results

    except Exception as e:
        print()
        print(&#34;processing tests interrupted with the following exception:&#34;)
        msg = &#34;Exception occurred in run_tests(): %s: %s&#34; % (str(type(e)), str(e))
        print(msg)
        raise e

    finally:
        with open(Path(output_directory, &#34;python_results.json&#34;), &#39;w&#39;) as f:
            json.dump(test_results, f, indent=2, ensure_ascii=False)

    print(&#34;processing tests finished.&#34;)


if __name__ == &#39;__main__&#39;:
    # try to close the external process if it will still be running on Python program end
    atexit.register(external_run.stop_jena_reasoning_service)

    run_tests()

    # close the external process
    external_run.stop_jena_reasoning_service()
    atexit.unregister(external_run.stop_jena_reasoning_service)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ctrlstrct_test.add_styling_to_trace"><code class="name flex">
<span>def <span class="ident">add_styling_to_trace</span></span>(<span>algorithm_json, trace_json, user_language=None, comment_style=None, add_tags=False) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Adds text line, tags and html form for each act in given trace and returns the same reference to the trace list.
<code>comment_style</code>: {None | 'use' | 'highlight'}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_styling_to_trace(algorithm_json, trace_json, user_language=None, comment_style=None, add_tags=False) -&gt; list:
    &#34;&#34;&#34;Adds text line, tags and html form for each act in given trace and returns the same reference to the trace list.
    `comment_style`: {None | &#39;use&#39; | &#39;highlight&#39;}
    &#34;&#34;&#34;
    try:
        assert isinstance(trace_json, (list, tuple)), &#34;The trace was not correctly constructed: &#34; + str(trace_json)

        for act_dict in trace_json:

            algorithm_element_id = act_dict[&#39;executes&#39;]
            elem = algorithm_json[&#34;id2obj&#34;].get(algorithm_element_id,
                                                algorithm_json[&#34;id2obj&#34;].get(str(algorithm_element_id), None))

            assert elem, f&#34;No element with id={algorithm_element_id} in given algorithm.&#34;

            if elem[&#39;id&#39;] == algorithm_json[&#34;entry_point&#34;][&#39;id&#39;]:
                # to make &#34;program began&#34; line: pass the root
                elem = algorithm_json

            act_text = act_line_for_alg_element(
                elem,
                phase=act_dict[&#39;phase&#39;],
                lang=user_language,
                expr_value=act_dict.get(&#39;value&#39;, None),
                use_exec_time=int(act_dict[&#39;n&#39;]),
            )
            if &#39;comment&#39; in act_dict and act_dict[&#39;comment&#39;] and comment_style is not None:
                act_text += &#34;    // &#34; + act_dict[&#39;comment&#39;]

            html_tags = trace_gen.styling.prepare_tags_for_line(act_text)

            if &#39;comment&#39; in act_dict and act_dict[&#39;comment&#39;] and comment_style == &#39;highlight&#39;:
                html_tags = {
                    &#34;tag&#34;: &#34;span&#34;,
                    &#34;attributes&#34;: {&#34;class&#34;: [&#34;warning&#34;]},
                    &#34;content&#34;: html_tags
                }

            add_json = {
                &#39;as_string&#39;: act_text,
                &#39;as_html&#39;: trace_gen.styling.to_html(html_tags),
            }
            act_dict.update(add_json)
            if add_tags:
                add_json = {
                    &#39;as_tags&#39;: html_tags,
                }
                act_dict.update(add_json)

        return trace_json
    except Exception as e:
        # raise e
        return f&#34;Server error in add_styling_to_trace() - {type(e).__name__}:\n\t{str(e)}&#34;</code></pre>
</details>
</dd>
<dt id="ctrlstrct_test.make_act_json"><code class="name flex">
<span>def <span class="ident">make_act_json</span></span>(<span>algorithm_json, algorithm_element_id: int, act_type: str, existing_trace_json, user_language=None) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p><code>act_type</code>: 'started' or 'finished' for complex, 'performed' for simple statements.
Returns full supplemented trace: list of dicts, each dict represents act object.
(Returns string with error description if an exception occurred)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_act_json(algorithm_json, algorithm_element_id: int, act_type: str, existing_trace_json,
                  user_language=None) -&gt; list:
    &#34;&#34;&#34;
    `act_type`: &#39;started&#39; or &#39;finished&#39; for complex, &#39;performed&#39; for simple statements.
    Returns full supplemented trace: list of dicts, each dict represents act object.
    (Returns string with error description if an exception occurred)
    &#34;&#34;&#34;
    # filter out incorrect acts (if any)
    existing_trace_json = existing_trace_json or ()
    existing_trace_list = [act for act in existing_trace_json if act[&#34;is_valid&#34;] == True]

    try:
        elem = algorithm_json[&#34;id2obj&#34;].get(algorithm_element_id,
                                            algorithm_json[&#34;id2obj&#34;].get(str(algorithm_element_id)))

        assert elem, f&#34;No element with id={algorithm_element_id} in given algorithm.&#34;

        max_id = max(a[&#39;id&#39;] for a in existing_trace_list) if existing_trace_list else 100 - 1

        result_acts = []
        # make line &#34;program began&#34; first
        if len(existing_trace_list) == 0 and elem[&#39;id&#39;] != algorithm_json[&#34;entry_point&#34;][&#39;id&#39;]:
            # создать строку &#34;program began&#34;
            act_text = act_line_for_alg_element(algorithm_json, phase=&#39;started&#39;,
                                                lang=user_language, )  # передаём сам корень алгоритма, так как его type==&#39;algorithm&#39;,
            max_id += 1
            html_tags = trace_gen.styling.prepare_tags_for_line(act_text)
            result_acts.append({
                &#39;executes&#39;: algorithm_json[&#34;entry_point&#34;][&#39;id&#39;],
                # ! а привязываем к глобальному коду (или функции main)
                &#39;name&#39;: algorithm_json[&#34;entry_point&#34;][&#39;name&#39;],
                &#39;phase&#39;: &#39;started&#39;,
                &#39;as_string&#39;: act_text,
                # &#39;as_tags&#39;: html_tags,
                &#39;as_html&#39;: trace_gen.styling.to_html(html_tags),
                &#39;id&#39;: max_id,
                &#39;n&#39;: 1,
                &#39;is_valid&#39;: True  # в начале трассы акт всегда такой
            })

        exec_time = 1 + len(
            [a for a in existing_trace_list if a[&#39;executes&#39;] == algorithm_element_id and a[&#39;phase&#39;] == act_type])

        expr_value = None
        if elem[&#39;type&#39;] == &#34;expr&#34; and act_type in (&#39;finished&#39;, &#39;performed&#39;):
            name = elem[&#39;name&#39;]
            expr_list = algorithm_json[&#39;expr_values&#39;].get(name, None)

            assert expr_list is not None, f&#34;No expression values provided for expression &#39;{name}&#39; in given algorithm.&#34;

            expr_value = get_ith_expr_value(expr_list, exec_time - 1)

            # assert expr_value is not None, f&#34;Not enough expression values provided for expression &#39;{name}&#39;: &#39;{expr_list}&#39; provided, # {exec_time} requested.&#34;
            if expr_value is None:
                expr_value = False
                print(f&#34;Info: use default value: {expr_value} for expression &#39;{name}&#39;.&#34;)

        act_text = act_line_for_alg_element(
            elem,
            phase=act_type,
            lang=user_language,
            expr_value=expr_value,
            use_exec_time=exec_time,
        )
        max_id += 1
        html_tags = trace_gen.styling.prepare_tags_for_line(act_text)
        act_json = {
            &#39;executes&#39;: elem[&#39;id&#39;],
            &#39;name&#39;: elem[&#39;name&#39;],
            &#39;phase&#39;: act_type,
            &#39;as_string&#39;: act_text,
            # &#39;as_tags&#39;: html_tags,
            &#39;as_html&#39;: trace_gen.styling.to_html(html_tags),
            &#39;id&#39;: max_id,
            &#39;n&#39;: exec_time,
            &#39;is_valid&#39;: None,  # пока нет информации о корректности такого акта
            # &#39;is_valid&#39;: True,  # debug !!
        }
        if expr_value is not None:
            act_json[&#39;value&#39;] = expr_value

        result_acts.append(act_json)

        return existing_trace_list + result_acts
    except Exception as e:
        # raise e
        return f&#34;Server error in make_act_json() - {type(e).__name__}:\n\t{str(e)}&#34;</code></pre>
</details>
</dd>
<dt id="ctrlstrct_test.process_algorithm_and_trace_from_json"><code class="name flex">
<span>def <span class="ident">process_algorithm_and_trace_from_json</span></span>(<span>alg_tr: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Demonstration entry point.
:param alg_tr: a dict with at least keys "trace", "algorithm"
:return: feedback{"messages": [&hellip;], "mistakes": [&hellip;]}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_algorithm_and_trace_from_json(alg_tr: dict):
    &#34;&#34;&#34;
    Demonstration entry point.
    :param alg_tr: a dict with at least keys &#34;trace&#34;, &#34;algorithm&#34;
    :return: feedback{&#34;messages&#34;: [...], &#34;mistakes&#34;: [...]}
    &#34;&#34;&#34;
    feedback = {&#34;messages&#34;: []}

    # validate input alg_tr
    # {
    #     &#34;trace_name&#34;    : str,
    #     &#34;algorithm_name&#34;: str,
    #     &#34;trace&#34;         : list,
    #     &#34;algorithm&#34;     : dict,
    #     &#34;header_boolean_chain&#34; : list of bool,
    # }
    try:
        assert alg_tr, f&#34;Empty data&#34;
        assert type(alg_tr) == dict, f&#34;&#39;JSON data is not a dict!&#34;;
        key = &#34;trace_name&#34;
        t = str
        assert key in alg_tr, f&#34;Key &#39;{key}&#39; is missing&#34;
        assert type(alg_tr[key]) == t, f&#34;&#39;{key}&#39; -&gt; is not a {str(t)}&#34;
        key = &#34;algorithm_name&#34;
        t = str
        assert key in alg_tr, f&#34;Key &#39;{key}&#39; is missing&#34;
        assert type(alg_tr[key]) == t, f&#34;&#39;{key}&#39; -&gt; is not a {str(t)}&#34;
        key = &#34;trace&#34;
        t = list
        assert key in alg_tr, f&#34;Key &#39;{key}&#39; is missing&#34;
        assert type(alg_tr[key]) == t, f&#34;&#39;{key}&#39; -&gt; is not a {str(t)}&#34;
        key = &#34;algorithm&#34;
        t = dict
        assert key in alg_tr, f&#34;Key &#39;{key}&#39; is missing&#34;
        assert type(alg_tr[key]) == t, f&#34;&#39;{key}&#39; -&gt; is not a {str(t)}&#34;
    except AssertionError as e:
        feedback[&#34;messages&#34;] += [f&#34;JSON error: {str(e)}\n{alg_tr}&#34;]
        return feedback

    alg_trs = [alg_tr]

    if not alg_trs:
        feedback[&#34;messages&#34;] += [&#34;Nothing to process: no valid algorithm / trace found.&#34;]
        return feedback

    # call it
    mistakes, err_msg = process_algorithms_and_traces(alg_trs)

    if err_msg:
        feedback[&#34;messages&#34;] += [err_msg]
    else:
        feedback[&#34;messages&#34;] += [&#34;Processing of algorithm &amp; trace finished OK.&#34;]
        feedback[&#34;mistakes&#34;] = mistakes

    return feedback</code></pre>
</details>
</dd>
<dt id="ctrlstrct_test.process_algorithms_and_traces"><code class="name flex">
<span>def <span class="ident">process_algorithms_and_traces</span></span>(<span>alg_trs_list: list, write_mistakes_to_acts=False) ‑> ('mistakes: list[str]', 'error_message: str or None')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_algorithms_and_traces(alg_trs_list: list, write_mistakes_to_acts=False) -&gt; (
        &#39;mistakes: list[str]&#39;, &#39;error_message: str or None&#39;):
    try:
        onto, mistakes = process_algtraces(alg_trs_list, verbose=0, mistakes_as_objects=False)

        if not mistakes and len(alg_trs_list) == 1:
            # try to find automatically polyfilled acts &amp; insert them into the trace
            # apply the simplest behaviour: skipped acts will be inserted to the previous-to-the-last position.
            if implicit_acts := list(onto.implicit_act.instances()):
                implicit_acts.sort(key=lambda a: a.id)
                acts_count = len(implicit_acts)
                print(acts_count, &#39;implicit_acts found, inserting them into trace.&#39;)

                algorithm = alg_trs_list[0][&#34;algorithm&#34;]
                # to be modified in-place (new acts will be inserted to prev. to the last)
                mutable_trace = alg_trs_list[0][&#34;trace&#34;]

                for imp_act in implicit_acts:
                    bound = imp_act.executes
                    assert bound
                    st = bound.boundary_of
                    assert st
                    algorithm_element_id = st.id
                    if onto.act_end in imp_act.is_a:
                        act_type = &#34;finished&#34;
                    elif onto.act_begin in imp_act.is_a:
                        act_type = &#34;started&#34;
                    else:
                        raise ValueError(&#34;implicit act has no begin/end type!: %s&#34; % imp_act)
                    appended_trace = make_act_json(algorithm_json=algorithm, algorithm_element_id=algorithm_element_id,
                                                  act_type=act_type, existing_trace_json=mutable_trace[:-1],
                                                  user_language=None)
                    assert len(appended_trace) &gt;= 2, appended_trace
                    mutable_trace.insert(-1, appended_trace[-1])
            # end for

            if finish_trace_acts := list(onto.finish_trace_act.instances()):
                # finish_trace_act exists =&gt; finish the trace.

                print(&#39;finish_trace_act found, closing the trace.&#39;)
                act = finish_trace_acts[0]

                algorithm = alg_trs_list[0][&#34;algorithm&#34;]
                # to be modified in-place (new acts will be inserted to prev. to the last)
                mutable_trace = alg_trs_list[0][&#34;trace&#34;]

                bound = act.executes
                assert bound
                end_of_trace_bound = bound.consequent[0]
                assert end_of_trace_bound
                st = end_of_trace_bound.boundary_of
                assert st

                algorithm_element_id = st.id
                act_type = &#34;finished&#34;

                appended_trace = make_act_json(algorithm_json=algorithm, algorithm_element_id=algorithm_element_id,
                                              act_type=act_type, existing_trace_json=mutable_trace[:],
                                              user_language=None)

                assert len(appended_trace) &gt;= 2, appended_trace
                new_last_line = appended_trace[-1]

                # создать строку &#34;program ended&#34;
                act_text = act_line_for_alg_element(algorithm, phase=&#39;finished&#39;,
                                                    lang=None, )  # передаём сам корень алгоритма, так как его type==&#39;algorithm&#39;,
                # обновить в строке трассы, т.к. по умолчанию генерируется &#39;следование global_code закончилось 1-й раз&#39;
                new_last_line[&#34;as_string&#34;] = act_text
                html_tags = trace_gen.styling.prepare_tags_for_line(act_text)
                new_last_line[&#39;as_html&#39;] = trace_gen.styling.to_html(html_tags)

                mutable_trace.append(new_last_line)
                ### print(&#34;+=+ inserted closing act:&#34;, new_last_line[&#34;as_string&#34;])

        delete_ontology(onto)

        if write_mistakes_to_acts and len(alg_trs_list) != 1:
            print(&#34;** Warning!: write_mistakes_to_acts is inapplicable when traces count =&#34;, len(alg_trs_list), &#34;(!=1)&#34;)
        if write_mistakes_to_acts and len(alg_trs_list) == 1:
            # ошибки нужны, и сейчас не режим тестирования
            trace = alg_trs_list[0][&#39;trace&#39;]
            for mistake in mistakes:
                act_id = mistake[&#34;id&#34;][0]
                for act_obj in list(find_by_keyval_in(&#34;id&#34;, act_id, trace)):
                    new_explanations = act_obj.get(&#34;explanations&#34;, []) + mistake[&#34;explanations&#34;]
                    act_obj[&#34;explanations&#34;] = sorted(set(new_explanations))
                    if not act_obj[&#34;explanations&#34;]:  # был пустой список - запишем хоть что-то
                        act_obj[&#34;explanations&#34;] = [&#34;Ошибка обнаружена, но вид ошибки не определён.&#34;]
                    act_obj[&#34;mistakes&#34;] = mistake
                    act_obj[&#34;is_valid&#34;] = False
                    if &#39;value&#39; in act_obj:
                        print(&#34; ***** Reset expr evaluation value.&#34;)
                        act_obj[&#34;value&#34;] = &#34;not evaluated&#34;
                        # del act_obj[&#34;value&#34;]
                        alg_data = alg_trs_list[0][&#39;algorithm&#39;]
                        # rewrite this act
                        add_styling_to_trace(alg_data, [act_obj])
                # break

            # Apply correctness mark to other acts:  act_obj[&#34;is_valid&#34;] = True
            for act_obj in trace:
                if act_obj[&#34;is_valid&#34;] is None:
                    act_obj[&#34;is_valid&#34;] = True

            # Признак окончания трассы
            # set act_obj[&#34;is_final&#34;] = True for end of the topmost statement
            top_stmts = set()
            for alg_obj in find_by_keyval_in(&#34;type&#34;, &#34;algorithm&#34;, alg_trs_list):
                top_stmts.add(alg_obj[&#34;entry_point&#34;][&#34;body&#34;][-1][&#34;id&#34;])
            assert top_stmts, top_stmts

            for act_obj in trace:
                if (act_obj[&#34;is_valid&#34;] == True
                        and act_obj[&#34;phase&#34;] in (&#39;finished&#39;, &#34;performed&#34;)
                        and act_obj[&#34;executes&#34;] in top_stmts):
                    act_obj[&#34;is_final&#34;] = True

        return mistakes, None
    except Exception as e:
        msg = &#34;Exception occured in process_algorithms_and_traces(): %s: %s&#34; % (str(type(e)), str(e))
        raise e
        print(msg)
        return [], msg</code></pre>
</details>
</dd>
<dt id="ctrlstrct_test.run_tests"><code class="name flex">
<span>def <span class="ident">run_tests</span></span>(<span>input_directory='../data/python/', output_directory='../results/')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_tests(input_directory=&#34;../data/python/&#34;, output_directory=&#34;../results/&#34;):
    test_results = {}
    try:
        for file in glob(os.path.join(input_directory, &#39;*.json&#39;)):
            path = Path(file)
            print(&#34;processing test:&#34;, path.name)
            with open(path) as f:
                input_data = json.load(f)

            results = process_algorithm_and_trace_from_json(input_data)

            test_results[path.stem] = results

    except Exception as e:
        print()
        print(&#34;processing tests interrupted with the following exception:&#34;)
        msg = &#34;Exception occurred in run_tests(): %s: %s&#34; % (str(type(e)), str(e))
        print(msg)
        raise e

    finally:
        with open(Path(output_directory, &#34;python_results.json&#34;), &#39;w&#39;) as f:
            json.dump(test_results, f, indent=2, ensure_ascii=False)

    print(&#34;processing tests finished.&#34;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ctrlstrct_test.add_styling_to_trace" href="#ctrlstrct_test.add_styling_to_trace">add_styling_to_trace</a></code></li>
<li><code><a title="ctrlstrct_test.make_act_json" href="#ctrlstrct_test.make_act_json">make_act_json</a></code></li>
<li><code><a title="ctrlstrct_test.process_algorithm_and_trace_from_json" href="#ctrlstrct_test.process_algorithm_and_trace_from_json">process_algorithm_and_trace_from_json</a></code></li>
<li><code><a title="ctrlstrct_test.process_algorithms_and_traces" href="#ctrlstrct_test.process_algorithms_and_traces">process_algorithms_and_traces</a></code></li>
<li><code><a title="ctrlstrct_test.run_tests" href="#ctrlstrct_test.run_tests">run_tests</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>