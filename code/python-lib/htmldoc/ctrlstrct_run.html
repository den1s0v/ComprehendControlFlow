<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ctrlstrct_run API documentation</title>
<meta name="description" content="Obtaining algorithms and traces,
filling a pure ontology with them,
adding rules defined in text files,
running reasoning with Jena reasoner (bundled …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ctrlstrct_run</code></h1>
</header>
<section id="section-intro">
<p>Obtaining algorithms and traces,
filling a pure ontology with them,
adding rules defined in text files,
running reasoning with Jena reasoner (bundled in an external service running on localhost).</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># ctrlstrct_run.py


&#34;&#34;&#34; Obtaining algorithms and traces,
filling a pure ontology with them,
adding rules defined in text files,
running reasoning with Jena reasoner (bundled in an external service running on localhost).
&#34;&#34;&#34;

import io
from transliterate import slugify

from common_helpers import Checkpointer
from explanations import format_explanation, get_leaf_classes
from external_run import invoke_jena_reasoning_service
from onto_helpers import *
from trace_gen.dict_helpers import get_ith_expr_value, find_by_key_in, find_by_keyval_in

# (a global from owlready2)
onto_path.append(&#34;.&#34;)

ONTOLOGY_IRI = &#39;http://vstu.ru/poas/code&#39;

# options to not save the parts of ontology while doing reasoning
WRITE_INVOLVES_CONCEPT = False
WRITE_PRINCIPAL_VIOLATION = False
WRITE_SKOS_CONCEPT = False
WRITE_CONCEPT_FLAG_LABEL = False


def prepare_name(s):
    &#34;&#34;&#34;Transliterate given word (to latin chars) if needed&#34;&#34;&#34;
    return slugify(s, &#34;ru&#34;) or s


def link_objects(onto, iri_subj: str, prop_name: str, iri_obj: str, prop_superclasses=(Thing &gt;&gt; Thing,)):
    &#34;&#34;&#34;Make a relation between two individuals that must exist in the ontology. The property, however, is created if does not exist (the `prop_superclasses` are applied to the new property).&#34;&#34;&#34;
    prop = onto[prop_name]
    if not prop:
        with onto:
            # new property
            prop = types.new_class(prop_name, prop_superclasses)
    make_triple(onto[iri_subj], prop, onto[iri_obj])


def uniqualize_iri(onto, iri):
    &#34;&#34;&#34;uniqualize individual&#39;s name&#34;&#34;&#34;
    n = 2
    orig_iri = iri
    while onto[iri]:  # while the name is in use
        # modify the name
        iri = orig_iri + (&#34;_%d&#34; % n)
        n += 1
    return iri



class TraceTester():
    &#34;&#34;&#34; manage preparation of algorithm &amp; trace data injection into ontology
    (before reasoning run)
    &#34;&#34;&#34;

    def __init__(self, trace_data):
        &#34;&#34;&#34;trace_data: dict like
         {
            &#34;trace_name&#34;    : str,
            &#34;algorithm_name&#34;: str,
            &#34;trace&#34;         : list,
            &#34;algorithm&#34;     : dict,
            &#34;header_boolean_chain&#34; : list of bool - chain of conditions results
         }
        &#34;&#34;&#34;
        self.data = trace_data

        # index of all objects of the ALGORITHM for quick search by id
        self.id2obj = self.data[&#34;algorithm&#34;].get(&#34;id2obj&#34;, {})

        self.initial_repair_data()

        self.act_iris = []

        self._maxID = 1

    def initial_repair_data(self):
        &#34;&#34;&#34;patch data if it is not connected properly but is replicated instead (ex. after JSON serialization)&#34;&#34;&#34;

        # repair dicts&#39; &#34;id&#34; values that are str, not int
        k = &#39;id&#39;
        for d in find_by_key_in(k, self.data):
            if isinstance(d[k], str):
                d[k] = int(d[k])
        # repair dicts keys that are str, not int
        for k in list(self.id2obj.keys()):
            if isinstance(k, str):
                self.id2obj[int(k)] = self.id2obj[k]
                del self.id2obj[k]

        data = self.data[&#34;algorithm&#34;]  # data to repair

        if &#34;functions&#34; not in data:
            data[&#34;functions&#34;] = ()

        roots = data[&#34;global_code&#34;], data[&#34;functions&#34;]  # where actual data to be stored

        k = &#39;id&#39;
        for d in find_by_keyval_in(k, data[&#34;entry_point&#34;][k], roots):
            data[&#34;entry_point&#34;] = d  # reassign the appropriate node from roots (global_code or main function)
            break

        for ID in list(self.id2obj.keys()):
            for d in find_by_keyval_in(k, ID, roots):
                self.id2obj[ID] = d  # reassign the appropriate node from roots
                break

    def newID(self, what=None):
        &#34;&#34;&#34;Increment and return new unused integer ID&#34;&#34;&#34;
        while True:
            self._maxID += 1
            if self._maxID not in self.id2obj:
                break
        return self._maxID

    def alg_entry(self):
        &#34;&#34;&#34;Get entry point of algorithm&#34;&#34;&#34;
        if &#34;entry_point&#34; in self.data[&#34;algorithm&#34;]:
            alg_node = self.data[&#34;algorithm&#34;][&#34;entry_point&#34;]
        else:
            raise &#34;Cannot resolve &#39;entry_point&#39; from algorithm&#39;s keys: &#34; + str(list(self.data[&#34;algorithm&#34;].keys()))
        return alg_node

    def make_correct_trace(self, noop=False):
        &#34;&#34;&#34;Fill `self.data[&#34;correct_trace&#34;]` with correct sequence of acts
        taking care of control-condition values.
        This repeats ordinary logic of each control-structure in the algorithm.&#34;&#34;&#34;

        self.data[&#34;correct_trace&#34;] = []
        self.expr_id2values = {}

        if noop:
            return  # !!!

        def _gen(states_str):
            for ch in states_str:
                yield bool(int(ch))
            while 1:
                yield None

        self.last_cond_tuple = (-1, False)
        self.consequent_mode = &#34;normal&#34;  # other values: &#34;return&#34;, &#34;break&#34;, &#34;continue&#34;

        self._maxID = max(self._maxID, max(map(int, self.id2obj.keys())) + 10)

        # decide where to read expr values from
        self.values_source = None
        if self.data[&#34;header_boolean_chain&#34;]:
            # source №1: the boolean chain attached to the trace
            self.values_source = &#34;boolean_chain&#34;
            self.condition_value_generator = _gen(self.data[&#34;header_boolean_chain&#34;])
        elif self.data[&#34;algorithm&#34;][&#34;expr_values&#34;]:
            # source №2: the values defined beside algorithm lines (this is used for 1-1 case when no boolean chain specified)
            self.values_source = &#34;algorithm&#34;
        else:
            # source №3: the values defined beside trace lines
            #  (this is less preferred as the trace may contain errors)
            self.values_source = &#34;trace&#34;


        def next_cond_value(expr_name=None, executes_id=None, n=None, default=False):

            i, _ = self.last_cond_tuple
            v = None

            if self.values_source == &#34;boolean_chain&#34;:
                v = next(self.condition_value_generator)
            else:
                assert n is not None, str(n)

                if self.values_source == &#34;algorithm&#34;:
                    assert expr_name is not None, str(expr_name)
                    expr_values_dict = self.data[&#34;algorithm&#34;][&#34;expr_values&#34;]
                    if expr_name in expr_values_dict:
                        expr_values = expr_values_dict[expr_name]
                    else:
                        raise ValueError(
                            f&#34;Algorithm processing error: No values of condition expression &#39;{expr_name}&#39; are provided.\nConsider example of how to specify values [true, true, false] for this condition as if it belongs to a loop:\n &lt;pre&gt;while {expr_name} -&gt; 110  // loop_name&lt;/pre&gt;&#34;)
                    v = get_ith_expr_value(expr_values, i=n - 1)

                if self.values_source == &#34;trace&#34;:
                    # find act with appropriate name and exec_time
                    # (phase is defaulted to &#34;finished&#34; as values are attached to these only)
                    assert expr_name is not None or executes_id is not None, str((expr_name, executes_id))
                    acts = [
                        act for act in
                        find_by_keyval_in(&#34;n&#34;, str(n), self.data[&#34;trace&#34;])
                        # act[&#34;n&#34;] == n and
                        if act[&#34;phase&#34;] in (&#34;finished&#34;, &#39;performed&#39;)
                            and (act[&#34;executes&#34;] == executes_id)
                    ]
                    if acts:
                        assert len(acts) == 1, &#34;Expected 1 act to be found, but got:\n &#34; + str(acts)
                        act = acts[0]
                        v = act.get(&#34;value&#34;, None)
                    else:
                        print(&#34;Warning: cannot find student_act: %s&#34; % (
                            dict(expr_name=expr_name, executes_id=executes_id, n=n)))

            if v is None:
                v = default
                print(&#34;next_cond_value(): defaulting to&#34;, default)
            self.last_cond_tuple = (i + 1, v)
            return v

        # long recursive function
        def make_correct_trace_for_alg_node(node):
            # copy reference
            result = self.data[&#34;correct_trace&#34;]

            if node[&#34;type&#34;] in {&#34;func&#34;}:

                phase = &#34;started&#34;
                ith = 1 + len([x for x in find_by_keyval_in(&#34;name&#34;, node[&#34;name&#34;], result) if x[&#34;phase&#34;] == phase])
                result.append({
                    &#34;id&#34;: self.newID(),
                    &#34;name&#34;: node[&#34;name&#34;],
                    &#34;executes&#34;: node[&#34;body&#34;][&#34;id&#34;],
                    &#34;phase&#34;: phase,
                    &#34;n&#34;: ith,
                    # &#34;text_line&#34;: None,
                    # &#34;comment&#34;: None,
                })

                for body_node in node[&#34;body&#34;][&#34;body&#34;]:
                    make_correct_trace_for_alg_node(body_node)

                if self.consequent_mode != &#34;normal&#34;:
                    # return encountered
                    self.consequent_mode = &#34;normal&#34;

                phase = &#34;finished&#34;
                ith = 1 + len([x for x in find_by_keyval_in(&#34;name&#34;, node[&#34;name&#34;], result) if x[&#34;phase&#34;] == phase])
                result.append({
                    &#34;id&#34;: self.newID(),
                    &#34;name&#34;: node[&#34;name&#34;],
                    &#34;executes&#34;: node[&#34;body&#34;][&#34;id&#34;],
                    &#34;phase&#34;: phase,
                    &#34;n&#34;: ith,
                    # &#34;text_line&#34;: None,
                    # &#34;comment&#34;: None,
                })

            if node[&#34;type&#34;] in {&#34;sequence&#34;, &#34;else&#34;}:

                # do not wrap &#39;global_code&#39;
                if node[&#34;name&#34;] != &#39;global_code&#39;:
                    phase = &#34;started&#34;
                    ith = 1 + len([x for x in find_by_keyval_in(&#34;name&#34;, node[&#34;name&#34;], result) if x[&#34;phase&#34;] == phase])
                    result.append({
                        &#34;id&#34;: self.newID(),
                        &#34;name&#34;: node[&#34;name&#34;],
                        &#34;executes&#34;: node[&#34;id&#34;],
                        &#34;phase&#34;: phase,
                        &#34;n&#34;: ith,
                        # &#34;text_line&#34;: None,
                        # &#34;comment&#34;: None,
                    })

                for body_node in node[&#34;body&#34;]:
                    make_correct_trace_for_alg_node(body_node)
                    if self.consequent_mode != &#34;normal&#34;:
                        break

                # do not wrap &#39;global_code&#39;
                if node[&#34;name&#34;] != &#39;global_code&#39;:
                    phase = &#34;finished&#34;
                    ith = 1 + len([x for x in find_by_keyval_in(&#34;name&#34;, node[&#34;name&#34;], result) if x[&#34;phase&#34;] == phase])
                    result.append({
                        &#34;id&#34;: self.newID(),
                        &#34;name&#34;: node[&#34;name&#34;],
                        &#34;executes&#34;: node[&#34;id&#34;],
                        &#34;phase&#34;: phase,
                        &#34;n&#34;: ith,
                        # &#34;text_line&#34;: None,
                        # &#34;comment&#34;: None,
                    })

            if node[&#34;type&#34;] in {&#34;alternative&#34;}:

                phase = &#34;started&#34;
                ith = 1 + len([x for x in find_by_keyval_in(&#34;name&#34;, node[&#34;name&#34;], result) if x[&#34;phase&#34;] == phase])
                result.append({
                    &#34;id&#34;: self.newID(),
                    &#34;name&#34;: node[&#34;name&#34;],
                    &#34;executes&#34;: node[&#34;id&#34;],
                    &#34;phase&#34;: phase,
                    &#34;n&#34;: ith,
                    # &#34;text_line&#34;: None,
                    # &#34;comment&#34;: None,
                })

                for branch in node[&#34;branches&#34;]:
                    make_correct_trace_for_alg_node(branch)
                    if self.last_cond_tuple[1] == True:
                        break
                    if self.consequent_mode != &#34;normal&#34;:
                        break

                phase = &#34;finished&#34;
                ith = 1 + len([x for x in find_by_keyval_in(&#34;name&#34;, node[&#34;name&#34;], result) if x[&#34;phase&#34;] == phase])
                result.append({
                    &#34;id&#34;: self.newID(),
                    &#34;name&#34;: node[&#34;name&#34;],
                    &#34;executes&#34;: node[&#34;id&#34;],
                    &#34;phase&#34;: phase,
                    &#34;n&#34;: ith,
                    # &#34;text_line&#34;: None,
                    # &#34;comment&#34;: None,
                })

            if node[&#34;type&#34;] in {&#34;if&#34;, &#34;else-if&#34;}:
                make_correct_trace_for_alg_node(node[&#34;cond&#34;])
                _, cond_v = self.last_cond_tuple
                if cond_v:
                    phase = &#34;started&#34;
                    ith = 1 + len([x for x in find_by_keyval_in(&#34;name&#34;, node[&#34;name&#34;], result) if x[&#34;phase&#34;] == phase])
                    result.append({
                        &#34;id&#34;: self.newID(),
                        &#34;name&#34;: node[&#34;name&#34;],
                        &#34;executes&#34;: node[&#34;id&#34;],
                        &#34;phase&#34;: phase,
                        &#34;n&#34;: ith,
                        # &#34;text_line&#34;: None,
                        # &#34;comment&#34;: None,
                    })

                    for body_node in node[&#34;body&#34;]:
                        make_correct_trace_for_alg_node(body_node)
                        if self.consequent_mode != &#34;normal&#34;:
                            break

                    phase = &#34;finished&#34;
                    ith = 1 + len([x for x in find_by_keyval_in(&#34;name&#34;, node[&#34;name&#34;], result) if x[&#34;phase&#34;] == phase])
                    result.append({
                        &#34;id&#34;: self.newID(),
                        &#34;name&#34;: node[&#34;name&#34;],
                        &#34;executes&#34;: node[&#34;id&#34;],
                        &#34;phase&#34;: phase,
                        &#34;n&#34;: ith,
                        # &#34;text_line&#34;: None,
                        # &#34;comment&#34;: None,
                    })

            if node[&#34;type&#34;] in {&#34;expr&#34;}:
                phase = &#34;performed&#34;
                ith = 1 + len([x for x in find_by_keyval_in(&#34;name&#34;, node[&#34;name&#34;], result) if x[&#34;phase&#34;] == phase])
                value = next_cond_value(node[&#34;name&#34;], node[&#34;id&#34;], ith)
                self.expr_id2values[node[&#34;id&#34;]] = self.expr_id2values.get(node[&#34;id&#34;], []) + [value]
                result.append({
                    &#34;id&#34;: self.newID(),
                    &#34;name&#34;: node[&#34;name&#34;],
                    &#34;value&#34;: value,
                    &#34;executes&#34;: node[&#34;id&#34;],
                    &#34;phase&#34;: phase,
                    &#34;n&#34;: ith,
                    # &#34;text_line&#34;: None,
                    # &#34;comment&#34;: None,
                })

            if node[&#34;type&#34;] in {&#34;stmt&#34;, &#34;break&#34;, &#34;continue&#34;, &#34;return&#34;}:
                phase = &#34;performed&#34;
                ith = 1 + len([x for x in find_by_keyval_in(&#34;name&#34;, node[&#34;name&#34;], result) if x[&#34;phase&#34;] == phase])
                result.append({
                    &#34;id&#34;: self.newID(),
                    &#34;name&#34;: node[&#34;name&#34;],
                    &#34;executes&#34;: node[&#34;id&#34;],
                    &#34;phase&#34;: phase,
                    &#34;n&#34;: ith,
                    # &#34;text_line&#34;: None,
                    # &#34;comment&#34;: None,
                })
                if node[&#34;type&#34;] in {&#34;break&#34;, &#34;continue&#34;, &#34;return&#34;}:
                    self.consequent_mode = node[&#34;type&#34;]
                    return  # just stupidly stop current sequence

            # TODO: keep list of loop classes up-to-date
            if node[&#34;type&#34;] in {&#34;while_loop&#34;, &#34;do_while_loop&#34;, &#34;do_until_loop&#34;, &#34;for_loop&#34;, &#34;foreach_loop&#34;,
                                &#34;infinite_loop&#34;, }:

                phase = &#34;started&#34;
                ith = 1 + len([x for x in find_by_keyval_in(&#34;name&#34;, node[&#34;name&#34;], result) if x[&#34;phase&#34;] == phase])
                result.append({
                    &#34;id&#34;: self.newID(),
                    &#34;name&#34;: node[&#34;name&#34;],
                    &#34;executes&#34;: node[&#34;id&#34;],
                    &#34;phase&#34;: phase,
                    &#34;n&#34;: ith,
                    # &#34;text_line&#34;: None,
                    # &#34;comment&#34;: None,
                })

                inverse_cond = node[&#34;type&#34;] == &#34;do_until_loop&#34;
                stop_cond_value = True == inverse_cond

                def _loop_context():  # wrapper for return
                    # loop begin
                    if node[&#34;type&#34;] in {&#34;for_loop&#34;, &#34;foreach_loop&#34;}:
                        make_correct_trace_for_alg_node(node[&#34;init&#34;])

                    if node[&#34;type&#34;] in {&#34;while_loop&#34;, &#34;for_loop&#34;, &#34;foreach_loop&#34;}:
                        make_correct_trace_for_alg_node(node[&#34;cond&#34;])
                        if self.last_cond_tuple[1] == stop_cond_value:
                            return

                    # loop cycle
                    while (True):

                        if node[&#34;type&#34;] in {&#34;foreach_loop&#34;}:
                            make_correct_trace_for_alg_node(node[&#34;update&#34;])

                        # a loop iteration!
                        make_correct_trace_for_alg_node(node[&#34;body&#34;])

                        if self.consequent_mode == &#34;continue&#34;:
                            # reset mode
                            self.consequent_mode = &#34;normal&#34;
                        elif self.consequent_mode == &#34;break&#34;:
                            # reset mode
                            self.consequent_mode = &#34;normal&#34;
                            return
                        elif self.consequent_mode != &#34;normal&#34;:
                            # return encountered
                            return

                        if node[&#34;type&#34;] in {&#34;for_loop&#34;}:
                            make_correct_trace_for_alg_node(node[&#34;update&#34;])

                        if node[&#34;type&#34;] not in {&#34;infinite_loop&#34;}:
                            make_correct_trace_for_alg_node(node[&#34;cond&#34;])
                            if self.last_cond_tuple[1] == stop_cond_value:
                                return

                _loop_context()  # make a loop

                phase = &#34;finished&#34;
                ith = 1 + len([x for x in find_by_keyval_in(&#34;name&#34;, node[&#34;name&#34;], result) if x[&#34;phase&#34;] == phase])
                result.append({
                    &#34;id&#34;: self.newID(),
                    &#34;name&#34;: node[&#34;name&#34;],
                    &#34;executes&#34;: node[&#34;id&#34;],
                    &#34;phase&#34;: phase,
                    &#34;n&#34;: ith,
                    # &#34;text_line&#34;: None,
                    # &#34;comment&#34;: None,
                })

        alg_node = self.alg_entry()

        name = &#34;program&#34;
        phase = &#34;started&#34;
        self.data[&#34;correct_trace&#34;].append({
            &#34;id&#34;: self.newID(),
            &#34;name&#34;: name,
            &#34;executes&#34;: alg_node[&#34;id&#34;],
            &#34;phase&#34;: phase,
            &#34;n&#34;: 1,
            # &#34;text_line&#34;: None,
            # &#34;comment&#34;: None,
        })
        make_correct_trace_for_alg_node(alg_node)
        phase = &#34;finished&#34;
        self.data[&#34;correct_trace&#34;].append({
            &#34;id&#34;: self.newID(),
            &#34;name&#34;: name,
            &#34;executes&#34;: alg_node[&#34;id&#34;],
            &#34;phase&#34;: phase,
            &#34;n&#34;: 1,
            # &#34;text_line&#34;: None,
            # &#34;comment&#34;: None,
        })


    def inject_to_ontology(self, onto):

        self.inject_algorithm_to_ontology(onto)

        self.make_correct_trace(noop=True)
        self.prepare_act_candidates(onto)
        self.inject_trace_to_ontology(onto, self.data[&#34;trace&#34;], (), &#34;student_next&#34;)


    def prepare_id2obj(self):
        &#34;&#34;&#34;Fill `self.id2obj` with direct references to algorithm objects &#34;&#34;&#34;
        alg_objects = list(find_by_type(self.data[&#34;algorithm&#34;]))
        if not self.id2obj:
            # fill it once
            for d in alg_objects:
                if &#34;id&#34; in d:
                    self.id2obj[d[&#34;id&#34;]] = d
            # store to original algorithm dict
            self.data[&#34;algorithm&#34;][&#34;id2obj&#34;] = self.id2obj


    def inject_algorithm_to_ontology(self, onto):
        &#34;&#34;&#34;Prepares self.id2obj and writes algorithm to ontology if it isn&#39;t there.&#34;&#34;&#34;

        if &#34;entry_point&#34; not in self.data[&#34;algorithm&#34;]:
            alg_node = self.data[&#34;algorithm&#34;][&#34;global_code&#34;]
            # polyfill entry_point to be global_code
            self.data[&#34;algorithm&#34;][&#34;entry_point&#34;] = alg_node

        self.prepare_id2obj()

        with onto:
            if onto.algorithm_name and self.data[&#34;algorithm_name&#34;] in [s for _, s in
                                                                       onto.algorithm_name.get_relations()]:
                # do nothing as the algorithm is in the ontology
                return

            alg_objects = list(find_by_type(self.data[&#34;algorithm&#34;]))

            written_ids = set()

            # make algorithm classes and individuals
            for d in alg_objects:
                if &#34;id&#34; not in d:
                    continue
                id_ = d.get(&#34;id&#34;)

                # (once more) protection from objects cloned via JSON serialization
                if id_ in written_ids:
                    continue
                else:
                    written_ids.add(id_)

                type_ = d.get(&#34;type&#34;)
                name = d.get(&#34;name&#34;, None) or d.get(&#34;stmt_name&#34;, &#34;&#34;)

                assert type_, &#34;Error: No &#39;type&#39; in algorithm object: &#34; + str(d)

                id_ = int(id_)
                clean_name = prepare_name(name)

                class_ = onto[type_]
                if not class_:
                    # make a new class in the ontology
                    class_ = types.new_class(type_, (Thing,))

                # make the name of individual (instance) in the ontology
                iri = &#34;{}_{}&#34;.format(id_, clean_name)

                iri = uniqualize_iri(onto, iri)

                # save back to our dict (to bind to acts later)
                d[&#34;iri&#34;] = iri
                # make an instance
                obj = class_(iri)
                # bind id
                make_triple(obj, onto.id, id_)
                # bind name
                make_triple(obj, onto.stmt_name, name)

                # make special string link identifying algorithm
                if type_ == &#34;algorithm&#34;:
                    prop = onto[&#34;algorithm_name&#34;]
                    if not prop:
                        with onto:
                            # new named relation
                            prop = types.new_class(&#34;algorithm_name&#34;, (Thing &gt;&gt; str,))
                    make_triple(obj, prop, self.data[&#34;algorithm_name&#34;])
                else:
                    # connect begin &amp; end
                    class_ = onto.boundary
                    for prop_name in (&#34;begin_of&#34;, &#34;end_of&#34;):
                        bound = class_(prop_name + &#34;_&#34; + iri)
                        make_triple(bound, onto[prop_name], obj)

            # link the instances: repeat the structure completely
            for d in alg_objects:
                if &#34;id&#34; not in d:
                    continue
                for k in d:  # look through dict keys
                    v = d[k]
                    if isinstance(v, dict) and &#34;id&#34; in v and &#34;iri&#34; in v:
                        # connect all the properties of the instance
                        link_objects(onto, d[&#34;iri&#34;], k, v[&#34;iri&#34;], (Thing &gt;&gt; Thing, onto.parent_of,))
                    elif isinstance(v, (list, set)):
                        # make an ordered linked_list for list, unordered for set
                        # make a list if it contains normal &#34;our&#34; objects
                        subobject_iri_list = [subv[&#34;iri&#34;] for subv in v if
                                              isinstance(subv, dict) and &#34;id&#34; in subv and &#34;iri&#34; in subv]
                        if not subobject_iri_list:
                            continue

                        iri = d[&#34;iri&#34;]

                        # Any list (actions, branches, ...) must be formatted as linked_list.
                        if k == &#34;body&#34; and isinstance(v, list):
                            # make the object a sequence (needed for loop bodies, branches, functions)
                            onto[iri].is_a.append(onto.linked_list)

                        subelem__prop_name = k + &#34;_item&#34;
                        for i, subiri in enumerate(subobject_iri_list):
                            # main relation
                            link_objects(onto, iri, subelem__prop_name, subiri, (Thing &gt;&gt; Thing, onto.parent_of,))
                            if isinstance(v, list):  # for list only
                                # sequence
                                if i &gt;= 1:
                                    prev_iri = subobject_iri_list[i - 1]
                                    link_objects(onto, prev_iri, &#34;next&#34;, subiri)
                                # set the index of elem in the list
                                onto[subiri].item_index = i
                                # first / last
                                if i == 0:
                                    # mark as first elem of the list
                                    onto[subiri].is_a.append(onto.first_item)
                                if i == len(subobject_iri_list) - 1:
                                    # mark as last act of the list
                                    onto[subiri].is_a.append(onto.last_item)

    def prepare_act_candidates(self, onto):
        &#34;&#34;&#34;Create all required acts for each statement. &#34;&#34;&#34;

        alg_id2max_exec_n = {st_id: 0 for st_id in self.id2obj.keys()}  # executed stmt id to max exec_time of the act
        for act in self.data[&#34;correct_trace&#34;]:
            executed_id = act[&#34;executes&#34;]
            exec_n = act[&#34;n&#34;]
            alg_id2max_exec_n[executed_id] = exec_n  # assume &#34;n&#34;s appear consequently in the trace

        # ensure that student&#39;s acts exist
        for act in self.data[&#34;trace&#34;]:
            executed_id = act[&#34;executes&#34;]
            exec_n = act.get(&#34;n&#34;, &#34;1&#34;)
            alg_id2max_exec_n[executed_id] = max(
                int(exec_n),  # assume &#34;n&#34;s appear consequently in the trace
                int(alg_id2max_exec_n[executed_id]))

        entry_stmt_id = self.alg_entry()[&#34;id&#34;]

        max_act_ID = 1000

        def set_id(act_obj):
            nonlocal max_act_ID
            max_act_ID += 1
            make_triple(act_obj, onto.id, max_act_ID)

        # make top-level act representing the trace ...
        iri = f&#39;trace_{self.data[&#34;trace_name&#34;]}&#39;
        if self.data[&#34;header_boolean_chain&#34;]:
            iri += f&#39;_c{&#34;&#34;.join(map(str, map(int, self.data[&#34;header_boolean_chain&#34;])))}&#39;

        iri = iri.replace(&#34; &#34;, &#34;_&#34;).strip(&#34;_&#34;)

        iri = prepare_name(iri)
        iri = uniqualize_iri(onto, iri)
        trace_obj = onto.trace(iri)
        self.trace_obj = trace_obj  # remember for trace injection
        trace_obj.is_a.append(onto.correct_act)
        make_triple(trace_obj, onto.executes, onto[self.data[&#34;algorithm&#34;][&#34;iri&#34;]])
        set_id(trace_obj)
        make_triple(trace_obj, onto.index, 0)
        make_triple(trace_obj, onto.student_index, 0)
        make_triple(trace_obj, onto.exec_time, 0)  # set to 0 so next is 1
        make_triple(trace_obj, onto.depth, 0)  # set to 0 so next is 1
        make_triple(trace_obj, onto.in_trace, trace_obj)  # each act belongs to trace

        for st_id, max_n in alg_id2max_exec_n.items():

            alg_elem = self.id2obj[st_id]
            if alg_elem[&#34;type&#34;] in {&#34;algorithm&#34;}:
                continue

            # prepare data
            name = alg_elem.get(&#34;name&#34;, &#34;unkn&#34;)
            clean_name = prepare_name(name)

            mark2act_obj = {}  # executed stmt id to list of act iri&#39;s can be consequently used in trace

            for exec_n in range(1, max_n + 1):

                # make instances: act_begin, act_end
                number_mark = &#34;&#34; if max_n &lt;= 1 else (&#34;_n%02d&#34; % exec_n)
                iri_template = f&#34;%s_{clean_name}{number_mark}&#34;  # _i{index:02}

                for mark, class_, boundary_prop in [(&#34;b&#34;, onto.act_begin, onto.begin_of),
                                                    (&#34;e&#34;, onto.act_end, onto.end_of)]:
                    iri = iri_template % mark
                    iri = uniqualize_iri(onto, iri)

                    obj = class_(iri)

                    boundary = get_relation_subject(boundary_prop, onto[alg_elem[&#34;iri&#34;]])
                    make_triple(obj, onto.executes, boundary)

                    set_id(obj)
                    make_triple(obj, onto.exec_time, exec_n)
                    make_triple(obj, onto.in_trace, trace_obj)

                    # keep current value for next iteration
                    mark2act_obj[mark] = obj

                    # attach expr value: for act_end only!
                    if mark == &#34;e&#34; and alg_elem[&#34;type&#34;] in (&#34;expr&#34;,):
                        values = self.expr_id2values[st_id] if st_id in self.expr_id2values else []
                        # if len(values) &lt;= exec_n:
                        if exec_n &lt;= len(values):
                            value = values[exec_n - 1]
                        else:
                            value = False
                            print(&#34;attach expr value: defaulting to False...&#34;)
                        make_triple(obj, onto.expr_value, value)


    def inject_trace_to_ontology(self, onto, trace, act_classnames=(&#34;act&#34;,), next_propertyname=None):
        &#34;Writes specified trace to ontology assigning properties to pre-created acts.&#34;

        additional_classes = [onto[nm] for nm in act_classnames]
        assert all(additional_classes), f&#34;additional_classes={additional_classes}, {act_classnames}, {onto}&#34;

        # make trace acts as individuals

        prop_class = onto[next_propertyname]

        def connect_next_act(obj):
            trace_acts_list.append(obj)
            # generate a consecutive list
            if prop_class and len(trace_acts_list) &gt; 1:
                # bind next, if specified
                prev_obj = trace_acts_list[-2]
                obj = trace_acts_list[-1]
                make_triple(prev_obj, prop_class, obj)
            if trace_acts_list:
                num = len(trace_acts_list)
                make_triple(obj, onto.student_index, num)

        def find_act(class_, executes: int, exec_time: int, **fields: dict):
            for obj in class_.instances():
                if ((
                        # an act executes a boundary while trace executes algorithm itself
                        obj.executes.INDIRECT_boundary_of or obj.executes
                ).id == executes and
                        ((obj.exec_time == exec_time) or (exec_time is None)) and
                        (self.trace_obj in obj.in_trace) and
                        all((getattr(obj, k, None) == v) or (v is None) for k, v in fields.items())):
                    return obj
            print(
                f&#34;act not found: ex={executes}, {&#39;, &#39;.join([f&#39;n={exec_time}&#39;] + [f&#39;{k}={v}&#39; for k, v in fields.items()])}&#34;)
            return None

        with onto:
            i = 0
            trace_acts_list = []
            trace_acts_list.append(find_act(onto.trace, self.data[&#34;algorithm&#34;][&#34;id&#34;], 0))
            for d in trace:
                i += 1
                if &#34;id&#34; in d:
                    id_ = d.get(&#34;id&#34;)
                    executes = d.get(&#34;executes&#34;)
                    # phase: (started|finished|performed)
                    phase = d.get(&#34;phase&#34;)  # , &#34;performed&#34;
                    n = d.get(&#34;n&#34;, None) or d.get(&#34;n_&#34;, None)
                    iteration_n = d.get(&#34;iteration_n&#34;, None)
                    name = d.get(&#34;name&#34;, None) or d.get(&#34;action&#34;, None)  # !  name &lt;- action
                    text_line = d.get(&#34;text_line&#34;, None)
                    expr_value = d.get(&#34;value&#34;, None)

                    id_ = int(id_)
                    # clean_name = prepare_name(name)
                    phase_mark = {&#34;started&#34;: &#34;b&#34;, &#34;finished&#34;: &#34;e&#34;, &#34;performed&#34;: &#34;p&#34;, }[phase]
                    n = n and int(n)  # convert if not None (n cannot be 0)
                    # number_mark = &#34;&#34; if not n else (&#34;_n%d&#34; % n)

                    # find related algorithm element
                    assert executes in self.id2obj, (self.id2obj, d)
                    alg_elem = self.id2obj[executes]

                    if phase_mark in (&#34;b&#34;, &#34;p&#34;):
                        # act begin
                        obj = find_act(onto.act_begin, executes, n or None)
                        if obj:
                            for class_ in additional_classes:
                                obj.is_a.append(class_)
                            # bind the required properties
                            make_triple(obj, onto.text_line, text_line)
                            make_triple(obj, onto.id,
                                        id_)  # IDs may be non-unique, but must match the id of the acts from the GUI
                            if iteration_n:
                                make_triple(obj, onto.student_iteration_n, iteration_n)

                            connect_next_act(obj)
                        else:
                            print(&#34;  act name:&#34;, name)

                    if phase_mark in (&#34;e&#34;, &#34;p&#34;):
                        # конец акта
                        obj = find_act(onto.act_end, executes, n or None)
                        if obj:
                            for class_ in additional_classes:
                                obj.is_a.append(class_)
                            # bind the required properties
                            make_triple(obj, onto.text_line, text_line)
                            make_triple(obj, onto.id,
                                        id_)  # IDs may be non-unique, but must match the id of the acts from the GUI
                            if expr_value is not None:
                                make_triple(obj, onto.expr_value, expr_value)
                            if iteration_n:
                                make_triple(obj, onto.student_iteration_n, iteration_n)

                            connect_next_act(obj)
                        else:
                            print(&#34;  act name:&#34;, name)

    # end of TraceTester class


def make_trace_for_algorithm(alg_dict):
    &#34;&#34;&#34;just a wrapper for `TraceTester.make_correct_trace()` method&#34;&#34;&#34;
    try:
        trace_data = {
            &#34;algorithm&#34;: alg_dict,
            &#34;header_boolean_chain&#34;: None,
        }
        tt = TraceTester(trace_data)
        tt.prepare_id2obj()
        tt.make_correct_trace()

        # Clear alg_dict[&#34;id2obj&#34;] dictionary from recursive reference to alg_dict itself
        for key in alg_dict[&#34;id2obj&#34;]:
            if alg_dict[&#34;id2obj&#34;][key] is alg_dict:
                del alg_dict[&#34;id2obj&#34;][key]
                break

        return tt.data[&#34;correct_trace&#34;]
    except Exception as e:
        print(&#34;Error !&#34;)
        print(&#34;Error making correct_trace:&#34;)
        print(&#34; &#34;, e)
        # raise e  # useful for debugging
        return str(e)


def init_persistent_structure(onto):
    &#34;&#34;&#34;Fill ontology with static definitions (RDF/OWL classes and properties)&#34;&#34;&#34;
    skos = onto.get_namespace(&#34;http://www.w3.org/2004/02/skos/core#&#34;)

    with onto:
        # Статические определения

        # use shortcut instead of adding unnecessary class
        Concept = Thing

        if WRITE_CONCEPT_FLAG_LABEL:
            # skos:broader  (has broader, is sub-concept-of)
            class broader(AnnotationProperty):
                namespace = skos

        # annotation `has_bitflags`
        class has_bitflags(AnnotationProperty):
            &#34;&#34;&#34;a Concept can have label &amp; flags &#34;&#34;&#34;

        FLAGS_visible = 1
        FLAGS_target = 2

        # new property: id
        if not onto[&#34;id&#34;]:
            id_prop = types.new_class(&#34;id&#34;, (Thing &gt;&gt; int, FunctionalProperty,))

        # -&gt;
        class act(Concept):
            pass

        # --&gt;
        class act_begin(act):
            pass

        # ---&gt;
        class trace(act_begin):
            pass

        if WRITE_CONCEPT_FLAG_LABEL:
            trace.has_bitflags = 0 | FLAGS_target;
            trace.label = [&#39;execution trace&#39;]

        # --&gt;
        class act_end(act):
            pass

        # --&gt;
        class implicit_act(act):
            &#34;&#34;&#34;act that skipped by student but added instead by rules&#34;&#34;&#34;

        class finish_trace_act(act):
            &#39;&#39;&#39;class that marks an act;
            if an act with this class present,
            the trace can be automatically closed with &#34;program ended&#34;.&#39;&#39;&#39;

        # --&gt;
        class correct_act(act):
            pass

        # # --&gt;
        class normal_flow_correct_act(correct_act):
            pass

        # hide so far
        # class breaking_flow_correct_act(correct_act): pass
        # AllDisjoint([
        #   normal_flow_correct_act,
        #   breaking_flow_correct_act
        # ])

        # -&gt;
        class linked_list(Thing):
            pass

        # -&gt;
        class action(Concept):
            pass

        # annotation `atom_action`
        class atom_action(AnnotationProperty):
            &#34;&#34;&#34;action that is is atomic and always shown in &#39;performed&#39; phase &#34;&#34;&#34;

        class algorithm(Concept):
            pass

        class entry_point(algorithm &gt;&gt; action, FunctionalProperty):
            pass

        class boundary(Thing):
            &#34;&#34;&#34;A node of actual execution graph &#34;&#34;&#34;
            pass  # begin or end of an action

        class boundary_of(boundary &gt;&gt; action, FunctionalProperty):
            pass

        class begin_of(boundary_of):
            pass

        class end_of(boundary_of):
            pass

        class halt_of(boundary_of):
            pass  # interrupted_end_of

        class interrupt_origin(boundary &gt;&gt; boundary):
            pass

        # annotation `act_class`
        class act_class(AnnotationProperty):
            &#34;&#34;&#34;boundary_of property class -&gt; act_begin or act_end&#34;&#34;&#34;
            pass

        begin_of.act_class = act_begin
        end_of.act_class = act_end
        halt_of.act_class = act_end

        # helper
        class gathered_child_exec_till(act &gt;&gt; act):
            pass

        # helper
        class gather_child_exec_till(gathered_child_exec_till):
            pass

        # helper
        class child_executes(act &gt;&gt; boundary):
            pass

        # new property: consequent - ребро графа переходов, заменяющего правильную трассу
        class consequent(Thing &gt;&gt; Thing, ):
            pass

        # vicinity - the immediate future, before the condition
        class has_upcoming(boundary &gt;&gt; boundary, TransitiveProperty):
            pass

        # consecutive boundaries of the same type (start or end =&gt; end_of or halt_of)
        class collapse_bound(boundary &gt;&gt; boundary, TransitiveProperty):
            pass

        # class interrupting_consequent(consequent): pass
        # + subclasses
        class normal_consequent(consequent):
            pass

        class always_consequent(normal_consequent, has_upcoming):
            pass

        class on_true_consequent(normal_consequent):
            pass

        class on_false_consequent(normal_consequent):
            pass

        # -&gt;
        class sequence(action):
            pass

        if WRITE_CONCEPT_FLAG_LABEL:
            sequence.has_bitflags = 0
            sequence.label = &#39;последовательность&#39;

        # признак first
        class first_item(Thing, ):
            pass

        # признак last
        class last_item(Thing, ):
            pass

        # индекс в списке
        class item_index(Thing &gt;&gt; int, FunctionalProperty):
            pass

        # -&gt;
        class loop(action):
            pass

        if WRITE_CONCEPT_FLAG_LABEL:
            loop.has_bitflags = FLAGS_visible | FLAGS_target;
            loop.label = [&#39;Циклы&#39;]

        if loop:  # hide a block under code folding
            # classes that regulate the use of condition in a loop

            # normal condition effect (false-&gt;stop, true-&gt;start a body) like in while, do-while, for loop types
            class conditional_loop(loop):
                pass

            # no condition at all: infinite loop like while(true){...}. The only act endlessly executed is the loop body.
            class unconditional_loop(loop):
                pass

            # # inverse condition effect (false-&gt;start a body, true-&gt;stop) like in do-until loop
            # inverse_conditional_loop = types.new_class(&#34;inverse_conditional_loop&#34;, (loop,))

            # The constraint is not useful so far
            # AllDisjoint([conditional_loop, unconditional_loop])

            class infinite_loop(unconditional_loop):
                pass

            class ntimes_loop(unconditional_loop):
                pass

            # classes that regulate a loop execution start (which act should be first)
            #
            # start with cond
            class start_with_cond(conditional_loop):
                pass

            # start with body
            class start_with_body(loop):
                pass

            # start with init
            class start_with_init(conditional_loop):
                pass

            # The constraint is not useful so far
            # AllDisjoint([start_with_cond, start_with_body, start_with_init])

            # classes that regulate the use of &#34;update&#34; step in a for-like loop
            # (both subclasses of &#34;loop_with_initialization&#34; as that loop have &#34;update&#34; step too)
            #
            # update first, then the body, like in foreach loop type
            class pre_update_loop(conditional_loop):
                pass

            # body first, then the update, like in for(;;) loop type
            class post_update_loop(conditional_loop):
                pass

            AllDisjoint([pre_update_loop, post_update_loop])

            # classes that indicate whether condition and body follow each other instantly or not
            # (note that: these classes are not disjointed; these classes are to be inferred from another defined features via equivalent_to definition so no direct inheritance required for known loops)
            # class body_then_cond(loop):
            #     equivalent_to = [inverse_conditional_loop | (conditional_loop &amp; (Not(post_update_loop)))]
            # class cond_then_body(loop):
            #     equivalent_to = [conditional_loop &amp; (Not(pre_update_loop))]

            # workaround: do not use the inference, declare explicitly
            class cond_then_body(conditional_loop):
                pass

            class body_then_cond(conditional_loop):
                pass

            # classes that define well-known loops as subclasses of the above defined loop-feature classes.
            # These classes are to be used publicly
            class while_loop(start_with_cond):
                pass

            while_loop.is_a += [cond_then_body, body_then_cond]  # workaround
            while_loop.label = [&#34;WHILE&#34;]

            if WRITE_CONCEPT_FLAG_LABEL:
                while_loop.has_bitflags = FLAGS_visible | FLAGS_target;
                while_loop.broader = [loop]

            class do_while_loop(start_with_body):
                pass

            do_while_loop.is_a += [cond_then_body, body_then_cond]  # workaround
            do_while_loop.label = [&#34;DO-WHILE&#34;]

            if WRITE_CONCEPT_FLAG_LABEL:
                do_while_loop.has_bitflags = FLAGS_visible | FLAGS_target;
                do_while_loop.broader = [loop]

            # class do_until_loop(inverse_conditional_loop, postconditional_loop): pass
            # do_until_loop.is_a += [body_then_cond]  # workaround
            # do_until_loop.label = [&#34;DO-UNTIL&#34;]

            class for_loop(post_update_loop, start_with_init):
                pass

            for_loop.is_a += [cond_then_body]  # workaround
            for_loop.label = [&#34;FOR&#34;]

            if WRITE_CONCEPT_FLAG_LABEL:
                for_loop.has_bitflags = FLAGS_visible | FLAGS_target;
                for_loop.broader = [loop]

            class foreach_loop(pre_update_loop, start_with_cond):
                pass

            foreach_loop.is_a += [body_then_cond]  # workaround
            foreach_loop.label = [&#34;FOREACH&#34;]

            # if WRITE_CONCEPT_FLAG_LABEL:
            #     foreach_loop.has_bitflags = FLAGS_visible | FLAGS_target;
            #     foreach_loop.broader = [loop]

        # --&gt;
        class alt_branch(sequence):
            pass

        # if WRITE_CONCEPT_FLAG_LABEL:
        #     alt_branch.has_bitflags = FLAGS_visible | FLAGS_target;
        #     alt_branch.label = [&#39;Ветки развилки&#39;]

        class func(action):
            pass

        # class func(sequence): pass
        class alternative(action):
            pass

        if WRITE_CONCEPT_FLAG_LABEL:
            alternative.has_bitflags = FLAGS_visible | FLAGS_target;
            alternative.label = [&#39;if&#39;]

        for class_name in [
            &#34;if&#34;, &#34;else-if&#34;, &#34;else&#34;,
        ]:
            cls = types.new_class(class_name, (alt_branch,))
            if WRITE_CONCEPT_FLAG_LABEL:
                cls.has_bitflags = FLAGS_visible | FLAGS_target;
                cls.label = [class_name]
        if WRITE_CONCEPT_FLAG_LABEL:
            onto[&#34;if&#34;].has_bitflags = 0 | FLAGS_target;
            onto[&#34;if&#34;].broader = [alternative]
            onto[&#34;else-if&#34;].broader = [alternative]
            onto[&#34;else&#34;].broader = [alternative]

        for class_name in [
            &#34;expr&#34;, &#34;stmt&#34;, &#34;interrupt_action&#34;,
        ]:
            cls = types.new_class(class_name, (action,))
            cls.atom_action = True

        for class_name in [
            &#34;return&#34;, &#34;break&#34;, &#34;continue&#34;,  # have optional `interrupt_target`
        ]:
            cls = types.new_class(class_name, (onto[&#39;interrupt_action&#39;],))
            # add annotation name: rdfs:label
            cls.label = [class_name]
            cls.atom_action = True
            if WRITE_CONCEPT_FLAG_LABEL:
                cls.has_bitflags = FLAGS_visible | FLAGS_target;
        if WRITE_CONCEPT_FLAG_LABEL:
            # making schema for export
            class loop_break_continue(Thing): pass

            loop_break_continue.has_bitflags = FLAGS_visible | FLAGS_target;
            loop_break_continue.label = [&#39;Прерывание цикла&#39;]
            # loop_break_continue.label = [&#39;break &amp; continue&#39;]

            onto[&#34;break&#34;].broader = [loop_break_continue]
            onto[&#34;continue&#34;].broader = [loop_break_continue]

        # make some properties
        for prop_name in (&#34;body&#34;, &#34;cond&#34;, &#34;init&#34;, &#34;update&#34;, &#34;wrong_next_act&#34;, &#34;interrupt_target&#34;,):
            if not onto[prop_name]:
                types.new_class(prop_name, (Thing &gt;&gt; Thing,))

        # new property: executes
        prop_executes = types.new_class(&#34;executes&#34;, (Thing &gt;&gt; Thing, FunctionalProperty,))

        class executes_id(act &gt;&gt; int, FunctionalProperty):
            pass

        # new property: expr_value
        prop_expr_value = types.new_class(&#34;expr_value&#34;, (DataProperty, FunctionalProperty,))

        # new property: stmt_name
        prop_stmt_name = types.new_class(&#34;stmt_name&#34;, (Thing &gt;&gt; str, DataProperty, FunctionalProperty))

        # new property: next
        types.new_class(&#34;next&#34;, (Thing &gt;&gt; Thing,))
        types.new_class(&#34;next_act&#34;, (correct_act &gt;&gt; correct_act, FunctionalProperty, InverseFunctionalProperty))

        # new property: student_next
        types.new_class(&#34;student_next&#34;, (act &gt;&gt; Thing,))
        types.new_class(&#34;student_next_latest&#34;, (act &gt;&gt; act, onto.student_next))

        types.new_class(&#34;_insert_act_executing&#34;, (act &gt;&gt; boundary,))

        # new property: next_sibling -- binds acts adjacent to the execution time number
        # (with the start and end acts separated)
        next_sibling = types.new_class(&#34;next_sibling&#34;, (Thing &gt;&gt; Thing,))

        # new property: before
        # prop_before = types.new_class(&#34;before&#34;, (Thing &gt;&gt; Thing, TransitiveProperty))

        # new property: in_trace
        prop_in_trace = types.new_class(&#34;in_trace&#34;, (act &gt;&gt; trace,))

        # свойство index
        types.new_class(&#34;index&#34;, (Thing &gt;&gt; int, FunctionalProperty,))
        types.new_class(&#34;student_index&#34;, (Thing &gt;&gt; int, FunctionalProperty,))
        # номер итерации
        types.new_class(&#34;student_iteration_n&#34;, (act &gt;&gt; int, FunctionalProperty,))
        types.new_class(&#34;iteration_n&#34;, (act &gt;&gt; int, FunctionalProperty,))

        types.new_class(&#34;after_act&#34;, (Thing &gt;&gt; act,))

        # new property: exec_time
        prop_exec_time = types.new_class(&#34;exec_time&#34;, (Thing &gt;&gt; int, FunctionalProperty,))

        # new property: depth
        class depth(Thing &gt;&gt; int, FunctionalProperty, ):
            pass

        # # new property: correct_depth
        # prop_correct_depth = types.new_class(&#34;correct_depth&#34;, (Thing &gt;&gt; int, FunctionalProperty, ))

        # new property: text_line
        prop_text_line = types.new_class(&#34;text_line&#34;, (Thing &gt;&gt; int, FunctionalProperty,))

        # make string_placeholder properties
        class string_placeholder(Thing &gt;&gt; str):
            pass

        for suffix in (
                &#34;A&#34;,  # &#34;B&#34;, &#34;C&#34;, &#34;D&#34;, &#34;EX&#34;,
                &#34;A_bound&#34;,
                &#34;kind_of_loop&#34;,
                &#34;kind_of_action&#34;,
                &#34;TrueFalse&#34;,
                &#34;BEGIN&#34;,  # для CorrespondingEndMismatched
                &#34;EXTRA&#34;,  # для NotNeighbour
                # &#34;EXTRA_act&#34;,
                &#34;EXTRA_bound&#34;,  # &lt;-- ObjectProperty!
                &#34;MISSING&#34;,  # omitted before the current
                # &#34;MISSING_act&#34;,
                &#34;MISSING_bound&#34;,  # &lt;-- ObjectProperty!
                &#34;COND&#34;,  # any condition (general case)
                &#34;INNER&#34;,
                # для CorrespondingEndMismatched: A non-conforming beginning, which is the embedded action of a non-conforming end
                &#34;CONTEXT&#34;,  # (Incorrect) parent (on the trace)
                &#34;PARENT&#34;,  # correct parent
                &#34;PREVIOUS&#34;,  # TooLateInSequence: the one that should be after, but it is before the current one
                &#34;LOOP&#34;,
                &#34;LOOP_COND&#34;,
                &#34;INIT&#34;,
                &#34;UPDATE&#34;,
                &#34;ALT&#34;,
                &#34;ALT_COND&#34;,  # any of the conditions (lists all the conditions)
                &#34;CURRENT_ALT_COND&#34;,  # current condition
                # &#34;PREV_ALT_COND&#34;,
                &#34;LATEST_ALT_COND&#34;,  # performed last, but not the current condition
                &#34;EXPECTED_ALT_COND&#34;,  # expected but absent
                &#34;REQUIRED_COND&#34;,  # a condition that has not been calculated
                &#34;UNEXPECTED_ALT_COND&#34;,  # not expected, but present
                &#34;BRANCH&#34;,  # has already been calculated
                &#34;BRANCH2&#34;,
                &#34;EXPECTED_BRANCH&#34;, &#34;UNEXPECTED_BRANCH&#34;,
                &#34;SEQ&#34;,
                &#34;NEXT&#34;,
                &#34;NEXT_COND&#34;,
        ):
            prop_name = &#34;field_&#34; + suffix
            if not onto[prop_name]:
                prop_class_ = string_placeholder
                if not WRITE_INVOLVES_CONCEPT and suffix.endswith((&#39;_act&#39;, &#39;_bound&#39;)):
                    prop_class_ = ObjectProperty
                types.new_class(prop_name, (prop_class_,))

        class fetch_kind_of_loop(act &gt;&gt; action, ):
            pass

        class reason_kind(boundary &gt;&gt; Thing, ):
            pass

        class to_reason(Thing &gt;&gt; Thing, ):
            pass

        class from_reason(Thing &gt;&gt; Thing, ):
            pass

        # new property: corresponding_end
        class corresponding_end(act_begin &gt;&gt; act_end, ):
            pass

        class student_corresponding_end(act_begin &gt;&gt; act_end, ):
            pass

        class hasPartTransitive(Thing &gt;&gt; Thing, TransitiveProperty):
            pass

        # new property: parent_of
        class parent_of(hasPartTransitive, InverseFunctionalProperty):
            pass

        class student_parent_of(Thing &gt;&gt; Thing, InverseFunctionalProperty):
            pass

        class branches_item(parent_of):
            pass

        class body(parent_of):
            pass

        class body_item(parent_of):
            pass

        # объекты, спровоцировавшие ошибку
        if not onto[&#34;Erroneous&#34;]:
            Erroneous = types.new_class(&#34;Erroneous&#34;, (Thing,))

            # category2priority = None  # declare it later
            # class error_priority(Thing &gt;&gt; int): pass

            # class-level properties (called Annotations)
            class involves_concept(AnnotationProperty):
                pass

            class principal_violation(AnnotationProperty):
                pass

            # reason node can be associated with violations poassible at the step of solution
            class possible_violation(ObjectProperty):
                pass

            # make Erroneous subclasses
            # (class, [bases])
            for class_spec in [
                # (name, [bases], err_level, {related, concepts})

                # Sequence mistakes ...
                (&#34;CorrespondingEndMismatched&#34;, (), &#34;trace_structure&#34;, {&#39;action&#39;}),
                (&#34;WrongNext&#34;, (), &#34;general_wrong&#34;, {&#39;action&#39;}),

                # &#34;CorrespondingEndPerformedDifferentTime&#34;,
                # &#34;WrongExecTime&#34;,
                # &#34;ActStartsAfterItsEnd&#34;, &#34;ActEndsWithoutStart&#34;,
                # &#34;AfterTraceEnd&#34;,
                # &#34;DuplicateActInSequence&#34;,
                (&#34;ConditionMisuse&#34;, [&#34;WrongNext&#34;], &#34;general_wrong&#34;, {&#39;expr&#39;}),

                (&#34;WrongContext&#34;, (), &#34;wrong_context&#34;, {&#39;action&#39;}),
                # (&#34;MisplacedBefore&#34;, [&#34;WrongContext&#34;]),
                # (&#34;MisplacedAfter&#34;, [&#34;WrongContext&#34;]),
                (&#34;MisplacedDeeper&#34;, [&#34;WrongContext&#34;], &#34;wrong_context&#34;, {&#39;action&#39;}),
                (&#34;EndedDeeper&#34;, [&#34;WrongContext&#34;, ], &#34;wrong_context&#34;, {&#39;action&#39;}),  # +
                (&#34;EndedShallower&#34;, [&#34;WrongContext&#34;, &#34;CorrespondingEndMismatched&#34;], &#34;wrong_context&#34;, {&#39;action&#39;}),
                # не возникнет для первой ошибки в трассе.
                (&#34;OneLevelShallower&#34;, [&#34;WrongContext&#34;], &#34;concrete_wrong_context&#34;, {&#39;action&#39;}),  # +

                (&#34;NeighbourhoodError&#34;, [&#34;WrongNext&#34;], &#34;general_wrong&#34;, {&#39;action&#39;}),
                # check that one of the following is determined
                (&#34;UpcomingNeighbour&#34;, [&#34;NeighbourhoodError&#34;], &#34;missing&#34;, {&#39;action&#39;}),  #
                (&#34;NotNeighbour&#34;, [&#34;NeighbourhoodError&#34;], &#34;extra&#34;, {&#39;action&#39;}),  # disjoint with UpcomingNeighbour
                (&#34;WrongCondNeighbour&#34;, [&#34;NotNeighbour&#34;, &#34;ConditionMisuse&#34;], &#34;by_different_cond&#34;, {&#39;action&#39;}),  #

                # interrupted flow
                (&#34;UnexpectedWhenInterrupting&#34;, [&#34;NotNeighbour&#34;, ], &#34;extra&#34;, {&#39;action&#39;}),  #
                (&#34;TooEarlyWhenInterrupting&#34;, [&#34;UpcomingNeighbour&#34;, ], &#34;missing&#34;, {&#39;action&#39;}),  #
                (&#34;IgnoreInterruptingFlow&#34;, [&#34;UnexpectedWhenInterrupting&#34;, ], &#34;extra&#34;, {&#39;action&#39;}),  #

                # (&#34;ExtraAct&#34;, [&#34;WrongNext&#34;]),
                (&#34;DuplicateOfAct&#34;, [], &#34;extra&#34;, {&#39;sequence&#39;}),
                # &#34;MissingAct&#34;,
                # &#34;TooEarly&#34;, # right after missing acts
                # (&#34;DisplacedAct&#34;, [&#34;TooEarly&#34;,&#34;ExtraAct&#34;,&#34;MissingAct&#34;]), # act was moved somewhere
                (&#34;TooLateInSequence&#34;, [&#34;WrongNext&#34;], &#34;extra&#34;, {&#39;sequence&#39;}),  # +
                (&#34;TooEarlyInSequence&#34;, [&#34;WrongNext&#34;], &#34;missing&#34;, {&#39;sequence&#39;}),  # +
                (&#34;SequenceFinishedNotInOrder&#34;, (), &#34;extra&#34;, {&#39;sequence&#39;}),
                # выполнены все действия, но в конце не последнее; не возникнет для первой ошибки в трассе.
                (&#34;SequenceFinishedTooEarly&#34;, [&#34;SequenceFinishedNotInOrder&#34;], &#34;missing&#34;, {&#39;sequence&#39;}),  # +

                # Alternatives mistakes ...
                (&#34;NoFirstCondition&#34;, (), &#34;missing&#34;, {&#39;alternative&#39;, &#39;if&#39;, &#39;expr&#39;}),  # +
                (&#34;NoAlternativeEndAfterBranch&#34;, (), &#34;missing&#34;, {&#39;alternative&#39;, &#39;alt_branch&#39;}),  # +
                (&#34;CondtionNotNextToPrevCondition&#34;, (), &#34;extra&#34;, {&#39;alternative&#39;, &#39;else-if&#39;, &#39;expr&#39;}),  # +
                (&#34;ConditionAfterBranch&#34;, [&#34;NoAlternativeEndAfterBranch&#34;, &#34;CondtionNotNextToPrevCondition&#34;], &#34;extra&#34;,
                 {&#39;alternative&#39;, &#39;alt_branch&#39;, &#39;expr&#39;}),  # ~
                (&#34;DuplicateOfCondition&#34;, [&#34;CondtionNotNextToPrevCondition&#34;, &#34;ConditionAfterBranch&#34;], &#34;extra&#34;,
                 {&#39;alternative&#39;, &#39;if&#39;, &#39;else-if&#39;, &#39;expr&#39;}),  # +
                # (&#34;WrongBranch&#34;, [&#34;ExtraAct&#34;]),
                (&#34;BranchOfFalseCondition&#34;, [&#34;ConditionMisuse&#34;], &#34;by_different_cond&#34;,
                 {&#39;alternative&#39;, &#39;alt_branch&#39;, &#39;expr&#39;}),
                (&#34;AnotherExtraBranch&#34;, [&#34;NoAlternativeEndAfterBranch&#34;], &#34;extra&#34;, {&#39;alternative&#39;, &#39;alt_branch&#39;}),  # +
                (&#34;BranchWithoutCondition&#34;, (), &#34;extra&#34;, {&#39;alternative&#39;, &#39;alt_branch&#39;, &#39;expr&#39;}),  # +
                (&#34;BranchNotNextToCondition&#34;, [&#34;BranchWithoutCondition&#34;], &#34;missing&#34;,
                 {&#39;alternative&#39;, &#39;alt_branch&#39;, &#39;expr&#39;}),  # +
                (&#34;ElseBranchNotNextToLastCondition&#34;, [&#34;BranchWithoutCondition&#34;], &#34;extra&#34;,
                 {&#39;alternative&#39;, &#39;alt_branch&#39;, &#39;else&#39;, &#39;expr&#39;}),  # +
                (&#34;ElseBranchAfterTrueCondition&#34;,
                 [&#34;BranchWithoutCondition&#34;, &#34;ElseBranchNotNextToLastCondition&#34;, &#34;ConditionMisuse&#34;], &#34;by_different_cond&#34;,
                 {&#39;alternative&#39;, &#39;alt_branch&#39;, &#39;else&#39;, &#39;expr&#39;}),  # ~
                (&#34;NoBranchWhenConditionIsTrue&#34;, [&#34;ConditionMisuse&#34;], &#34;by_different_cond&#34;,
                 {&#39;alternative&#39;, &#39;alt_branch&#39;, &#39;expr&#39;}),  # +
                (&#34;LastConditionIsFalseButNoElse&#34;, (), &#34;missing&#34;, {&#39;alternative&#39;, &#39;alt_branch&#39;, &#39;else&#39;, &#39;expr&#39;}),  # +
                (&#34;NoNextCondition&#34;, (), &#34;missing&#34;, {&#39;alternative&#39;, &#39;expr&#39;}),  # ~
                (&#34;ConditionTooLate&#34;, [&#34;NoNextCondition&#34;, &#34;CondtionNotNextToPrevCondition&#34;], &#34;extra&#34;,
                 {&#39;alternative&#39;, &#39;expr&#39;}),  # - skip for now
                (
                        &#34;ConditionTooEarly&#34;, [&#34;NoFirstCondition&#34;, &#34;NoNextCondition&#34;, &#34;CondtionNotNextToPrevCondition&#34;],
                        &#34;extra&#34;,
                        {&#39;alternative&#39;, &#39;expr&#39;}),  # +
                (&#34;LastFalseNoEnd&#34;, (), &#34;missing&#34;, {&#39;alternative&#39;, &#39;expr&#39;}),  # +
                (&#34;AlternativeEndAfterTrueCondition&#34;, [&#34;ConditionMisuse&#34;], &#34;by_different_cond&#34;,
                 {&#39;alternative&#39;, &#39;alt_branch&#39;, &#39;expr&#39;}),  # +

                # Loops mistakes ...
                # a general Loop
                (&#34;NoLoopEndAfterFailedCondition&#34;, (), &#34;missing&#34;, {&#39;loop&#39;, &#39;expr&#39;}),  # +
                (&#34;LoopContinuedAfterFailedCondition&#34;, [&#34;NoLoopEndAfterFailedCondition&#34;, &#34;ConditionMisuse&#34;],
                 &#34;by_different_cond&#34;, {&#39;loop&#39;, &#39;expr&#39;}),  # +
                (&#34;IterationAfterFailedCondition&#34;, [&#34;LoopContinuedAfterFailedCondition&#34;], &#34;extra&#34;, {&#39;loop&#39;, &#39;expr&#39;}),
                # +
                (&#34;LoopEndsWithoutCondition&#34;, (), &#34;extra&#34;, {&#39;loop&#39;, &#39;expr&#39;}),  # +
                # start_with_cond
                (&#34;LoopStartIsNotCondition&#34;, (), &#34;missing&#34;, {&#39;while_loop&#39;, &#39;expr&#39;}),  # +
                # start_with_body
                (&#34;LoopStartIsNotIteration&#34;, (), &#34;missing&#34;, {&#39;do_while_loop&#39;}),  # +
                # cond_then_body (-&gt; true)
                (&#34;NoIterationAfterSuccessfulCondition&#34;, (), &#34;missing&#34;,
                 {&#39;while_loop&#39;, &#39;do_while_loop&#39;, &#39;for_loop&#39;, &#39;expr&#39;}),  # +
                (&#34;LoopEndAfterSuccessfulCondition&#34;, [&#34;NoIterationAfterSuccessfulCondition&#34;, &#34;ConditionMisuse&#34;],
                 &#34;by_different_cond&#34;, {&#39;while_loop&#39;, &#39;do_while_loop&#39;, &#39;for_loop&#39;, &#39;expr&#39;}),  # +
                # body_then_cond
                (&#34;NoConditionAfterIteration&#34;, (), &#34;missing&#34;, {&#39;while_loop&#39;, &#39;do_while_loop&#39;, &#39;expr&#39;}),  # +
                (&#34;NoConditionBetweenIterations&#34;, [&#34;NoConditionAfterIteration&#34;], &#34;missing&#34;,
                 {&#39;while_loop&#39;, &#39;do_while_loop&#39;, &#39;expr&#39;}),  # +
                # ForLoop
                (&#34;LoopStartsNotWithInit&#34;, (), &#34;missing&#34;, {&#39;for_loop&#39;, }),
                (&#34;InitNotAtLoopStart&#34;, (), &#34;extra&#34;, {&#39;for_loop&#39;, }),
                (&#34;NoConditionAfterForInit&#34;, (), &#34;missing&#34;, {&#39;for_loop&#39;, &#39;expr&#39;}),
                (&#34;IterationAfterForInit&#34;, [&#34;NoConditionAfterForInit&#34;], &#34;extra&#34;, {&#39;for_loop&#39;, }),
                (&#34;NoUpdateAfterIteration&#34;, (), &#34;missing&#34;, {&#39;for_loop&#39;, }),
                (&#34;UpdateNotAfterIteration&#34;, (), &#34;extra&#34;, {&#39;for_loop&#39;, }),
                (&#34;ForConditionAfterIteration&#34;, [&#34;UpdateNotAfterIteration&#34;], &#34;extra&#34;, {&#39;for_loop&#39;, &#39;expr&#39;}),
                (&#34;NoConditionAfterForUpdate&#34;, (), &#34;missing&#34;, {&#39;for_loop&#39;, }),
                # ForeachLoop
                (&#34;NoForeachUpdateAfterSuccessfulCondition&#34;, (), &#34;missing&#34;, {&#39;foreach_loop&#39;, }),
                (&#34;ForeachUpdateNotAfterSuccessfulCondition&#34;, (), &#34;extra&#34;, {&#39;foreach_loop&#39;, }),
                (&#34;NoIterationAfterForeachUpdate&#34;, (), &#34;missing&#34;, {&#39;foreach_loop&#39;, }),
                (&#34;IterationNotAfterForeachUpdate&#34;, (), &#34;extra&#34;, {&#39;foreach_loop&#39;, }),
            ]:
                if isinstance(class_spec, str):
                    types.new_class(class_spec, (Erroneous,))
                elif isinstance(class_spec, tuple):
                    class_name, base_names = class_spec[:2]
                    bases = tuple(
                        (onto[base_name] if type(base_name) is str else base_name) for base_name in base_names)
                    created_class = types.new_class(class_name, bases or (Erroneous,))
                    if WRITE_INVOLVES_CONCEPT:
                        related_concepts = class_spec[3]
                        created_class.involves_concept = list(map(onto.__getattr__, sorted(related_concepts)))

        for prop_name in (
                &#34;precursor&#34;, &#34;cause&#34;, &#34;has_causing_condition&#34;, &#34;should_be&#34;, &#34;should_be_before&#34;, &#34;should_be_after&#34;,
                &#34;context_should_be&#34;):
            if not onto[prop_name]:
                types.new_class(prop_name, (onto[&#34;Erroneous&#34;] &gt;&gt; Thing,))

        # make consequent subproperties (always_consequent is default base)
        for class_spec in [
            #: (name, optional base, [principal_violations])
            # &#34;FunctionBegin&#34;,
            # &#34;FunctionEnd&#34;,
            # &#34;FunctionBodyBegin&#34;,
            &#34;StmtEnd&#34;,
            &#34;ExprEnd&#34;,

            (&#34;Interrupted&#34;, 0, []),  # [??]
            (&#34;GlobalCodeBegin&#34;, 0, [&#39;TooEarlyInSequence&#39;, &#39;SequenceFinishedTooEarly&#39;]),
            (&#34;SequenceBegin&#34;, 0, [&#39;TooEarlyInSequence&#39;, &#39;SequenceFinishedTooEarly&#39;]),
            (&#34;SequenceNext&#34;, 0, [&#39;DuplicateOfAct&#39;, &#39;TooEarlyInSequence&#39;, &#39;SequenceFinishedTooEarly&#39;]),
            (&#34;SequenceEnd&#34;, 0, [&#39;DuplicateOfAct&#39;]),

            (&#34;AltBegin&#34;, 0, [&#39;NoFirstCondition&#39;]),  # 1st condition
            (&#34;AltBranchBegin&#34;, on_true_consequent, [&#39;NoBranchWhenConditionIsTrue&#39;]),
            # ElseBranchAfterTrueCondition (enabled by ELSE branch) - not included directly; see special rule from that whose process algorithms
            (&#34;NextAltCondition&#34;, on_false_consequent, [&#39;BranchOfFalseCondition&#39;]),
            (&#34;AltElseBranchBegin&#34;, on_false_consequent, [&#39;LastConditionIsFalseButNoElse&#39;, &#39;BranchOfFalseCondition&#39;]),
            (&#34;AltEndAllFalse&#34;, on_false_consequent, [&#39;LastFalseNoEnd&#39;]),
            (&#34;AltEndAfterBranch&#34;, 0, [&#39;NoAlternativeEndAfterBranch&#39;]),

            (&#34;PreCondLoopBegin&#34;, 0, [&#39;LoopStartIsNotCondition&#39;]),
            (&#34;PostCondLoopBegin&#34;, 0, [&#39;LoopStartIsNotIteration&#39;]),
            (&#34;IterationBeginOnTrueCond&#34;, on_true_consequent, [&#39;NoIterationAfterSuccessfulCondition&#39;]),
            # &#34;IterationBeginOnFalseCond&#34;,
            (&#34;LoopUpdateOnTrueCond&#34;, on_true_consequent, [&#39;NoForeachUpdateAfterSuccessfulCondition&#39;]),
            (&#34;IterationAfterUpdate&#34;, 0, [&#39;NoIterationAfterForeachUpdate&#39;]),
            (&#34;LoopEndOnFalseCond&#34;, on_false_consequent, [&#39;NoLoopEndAfterFailedCondition&#39;]),
            # &#34;LoopEndOnTrueCond&#34;,  # no rule yet?
            (&#34;LoopCondBeginAfterIteration&#34;, 0, [&#39;NoConditionAfterIteration&#39;]),
            (&#34;LoopWithInitBegin&#34;, 0, [&#39;LoopStartsNotWithInit&#39;]),
            (&#34;LoopCondBeginAfterInit&#34;, 0, [&#39;NoConditionAfterForInit&#39;]),
            (&#34;LoopUpdateAfterIteration&#34;, 0, [&#39;NoUpdateAfterIteration&#39;]),
            (&#34;LoopCondAfterUpdate&#34;, 0, [&#39;NoConditionAfterForUpdate&#39;]),
        ]:
            # types.new_class(class_name, (correct_act,))
            if isinstance(class_spec, str):
                types.new_class(class_spec, (always_consequent,))
            elif isinstance(class_spec, tuple):
                class_name, base_names = class_spec[:2]
                bases = tuple(
                    (onto[base_name] if type(base_name) is str else base_name) for base_name in [base_names] if
                    base_name)
                created_class = types.new_class(class_name, bases or (always_consequent,))
                if WRITE_PRINCIPAL_VIOLATION and len(class_spec) &gt;= 3:
                    violations = class_spec[2]
                    created_class.principal_violation = list(map(onto.__getattr__, violations))

        for prop_name in (&#34;reason&#34;,):  # for correct acts !
            if not onto[prop_name]:
                types.new_class(prop_name, (correct_act &gt;&gt; Thing,))


def extact_mistakes(onto, as_objects=False, group_by=(&#34;text_line&#34;,), filter_by_level=False) -&gt; dict:
    &#34;&#34;&#34;Searches for instances of trace_error class and constructs a dict of the following form:
        ```&#34;&lt;error_instance1_name&gt;&#34;: {
            &#34;classes&#34;: [&#34;list&#34;, &#34;of&#34;, &#34;class&#34;, &#34;names&#34;, ...],
            &#34;explanations&#34;: [&#34;list&#34;, &#34;of&#34;, &#34;messages&#34;, ...],
            &#34;&lt;property1_name&gt;&#34;: [&#34;list&#34;, &#34;of&#34;, &#34;property&#34;, &#34;values&#34;, ...],
            &#34;&lt;property2_name&gt;&#34;: [onto.iri_1, &#34;reference&#34;, &#34;can present&#34;, &#34;too&#34;, ...],
            ...
        },
        &#34;&lt;error_instance2_name&gt;&#34;: {},
        ...```

     &#34;&#34;&#34;
    error_classes = onto.Erroneous.descendants()  # a set of the descendant Classes (including self)

    properties_to_extract = (
        &#34;id&#34;, &#34;name&#34;, onto.precursor, onto.cause, onto.should_be, onto.should_be_before, onto.should_be_after,
        onto.context_should_be, onto.text_line,)

    # remove absent properties
    group_by = [pnm for pnm in group_by if onto[pnm]]
    # set default if empty so far
    group_by = group_by or (&#34;name&#34;,)

    def inst_keys(inst):
        values = []
        for prop_name in group_by:
            values.append(getattr(inst, prop_name) if hasattr(inst, prop_name) else None)
        return tuple(values)

    if filter_by_level:
        categories = [
            onto.UpcomingNeighbour,
            onto.WrongCondNeighbour,
            onto.NotNeighbour,
            onto.Erroneous
        ]
    else:
        categories = [onto.Erroneous]

    mistakes = {}

    for error_class in categories:
        # The .instances() class method can be used to iterate through all Instances of a Class (including its subclasses). It returns a generator.
        for inst in set(error_class.instances()):

            ###
            print(&#34;Erroneous instance:&#34;, inst.name)
            key = inst_keys(inst)
            d = mistakes.get(key, {})
            mistakes[key] = d

            for prop in properties_to_extract:
                values = []
                # fill values ...
                if isinstance(prop, str):
                    prop_name = prop
                    values.append(getattr(inst, prop_name))
                else:
                    prop_name = prop.name
                    for s, o in prop.get_relations():
                        if s == inst:
                            if not as_objects:
                                o = o.name if hasattr(o, &#34;name&#34;) else o
                            values.append(o)

                d[prop_name] = values

            classes = get_leaf_classes((set(inst.is_a) | set(d.get(&#34;classes&#34;, {}))) &amp; error_classes)
            d[&#34;classes&#34;] = [class_.name for class_ in classes]
            expanded_explanations = format_explanation(onto, inst)
            explanations = [d[&#34;explanation&#34;] for d in expanded_explanations]
            d[&#34;explanations&#34;] = sorted(set(d.get(&#34;explanations&#34;, []) + explanations))
            d[&#34;mistakes&#34;] = expanded_explanations
        if mistakes:
            break

    return mistakes


def create_ontology_tbox() -&gt; &#34;ontology&#34;:
    &#34;&#34;&#34;Create a new ontology that does not overlap ony other Owlready2 ontology
    and fill it with static definitions&#34;&#34;&#34;
    # create an ontology
    onto = get_isolated_ontology(ONTOLOGY_IRI)
    clear_ontology(onto, keep_tbox=False)

    with onto:
        # fill ontology wit static definitions
        init_persistent_structure(onto)
    return onto


def process_algtraces(trace_data_list, debug_rdf_fpath=None, verbose=1,
                      mistakes_as_objects=False, filter_by_level=False,
                      _eval_max_traces=None) -&gt; &#34;onto, mistakes_list&#34;:
    &#34;&#34;&#34;Write number of `algorithm - trace` pair to an ontology,
        perform extended reasoning and then extract and return the mistakes found.
    &#34;&#34;&#34;

    if verbose: ch = Checkpointer()

    onto = create_ontology_tbox()

    if verbose: ch.hit(&#34;create ontology tbox&#34;)

    # наполняем онтологию с нуля сущностями с теми именами, которые найдём в загруженных json-словарях

    if _eval_max_traces is not None:
        # adjust the list size
        if _eval_max_traces &lt;= len(trace_data_list):
            trace_data_list = trace_data_list[0:_eval_max_traces + 1]
        else:
            from itertools import cycle
            cycled = cycle(trace_data_list)
            for trace in cycled:
                trace_data_list.append(trace)
                if len(trace_data_list) == _eval_max_traces:
                    break

    for tr_data in trace_data_list:
        tt = TraceTester(tr_data)
        tt.inject_to_ontology(onto)
        if verbose: print(end=&#34;.&#34;)

    if verbose: ch.hit(&#34;fill ontology data&#34;)

    if debug_rdf_fpath:
        onto.save(file=debug_rdf_fpath, format=&#39;rdfxml&#39;)
        print(&#34;Saved RDF file: {} !&#34;.format(debug_rdf_fpath))

    # invoke through jenaService:
    # save ontology to buffer in memory
    # TODO: check if NTRIPLES will be processed faster!
    stream = io.BytesIO()
    onto.save(file=stream, format=&#39;rdfxml&#39;)
    result_rdf_bytes = invoke_jena_reasoning_service(rdfData=stream.getvalue())

    # Clear current ontology data
    delete_ontology(onto)

    # read from byte stream
    # use isolated worlds (keep concurrent threads in mind)
    onto = get_isolated_ontology(ONTOLOGY_IRI).load(
        fileobj=io.BytesIO(result_rdf_bytes),
        reload=True, only_local=True)

    if debug_rdf_fpath:
        onto.save(file=debug_rdf_fpath + &#34;_ext.rdf&#34;, format=&#39;rdfxml&#39;)
        print(f&#34;Saved RDF file: {debug_rdf_fpath}_ext.rdf !&#34;)

    if verbose: ch.hit(&#34;reasoning completed&#34;)

    mistakes = extact_mistakes(onto, as_objects=mistakes_as_objects, filter_by_level=filter_by_level)
    if verbose: ch.hit(&#34;mistakes extracted&#34;)

    return onto, list(mistakes.values())


def clear_ontology(onto, keep_tbox=False):
    &#34;&#34;&#34;Remove all concrete data from the ontology, keeping static definitions if required
    (removing everything by default)&#34;&#34;&#34;
    if not keep_tbox:
        for cls in onto.classes():
            destroy_entity(cls)
    for ind in onto.individuals():
        destroy_entity(ind)


def find_by_type(dict_or_list, types=(dict,), _not_entry=None):
    &#34;&#34;&#34;plain list of dicts or objects of specified type&#34;&#34;&#34;
    _not_entry = _not_entry or set()
    if isinstance(dict_or_list, types):
        yield dict_or_list
        _not_entry.add(id(dict_or_list))
    if isinstance(dict_or_list, dict):
        for v in dict_or_list.values():
            if id(v) not in _not_entry:
                yield from find_by_type(v, types, _not_entry)
    elif isinstance(dict_or_list, (list, tuple, set)):
        for v in dict_or_list:
            if id(v) not in _not_entry:
                yield from find_by_type(v, types, _not_entry)


def save_schema(file_path=&#39;jena/control-flow-statements-domain-schema.rdf&#39;):
    &#34;&#34;&#34;Save ontology data (static definitions only) as RDF file&#34;&#34;&#34;
    global WRITE_INVOLVES_CONCEPT
    global WRITE_PRINCIPAL_VIOLATION
    global WRITE_CONCEPT_FLAG_LABEL
    WRITE_INVOLVES_CONCEPT = True
    WRITE_PRINCIPAL_VIOLATION = True
    WRITE_CONCEPT_FLAG_LABEL = True
    create_ontology_tbox().save(file_path)

    print(&#34;Saved as:\t&#34;, file_path)


if __name__ == &#39;__main__&#39;:

    print(&#34;Please run *_test.py script instead!&#34;)
    exit()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ctrlstrct_run.clear_ontology"><code class="name flex">
<span>def <span class="ident">clear_ontology</span></span>(<span>onto, keep_tbox=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove all concrete data from the ontology, keeping static definitions if required
(removing everything by default)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_ontology(onto, keep_tbox=False):
    &#34;&#34;&#34;Remove all concrete data from the ontology, keeping static definitions if required
    (removing everything by default)&#34;&#34;&#34;
    if not keep_tbox:
        for cls in onto.classes():
            destroy_entity(cls)
    for ind in onto.individuals():
        destroy_entity(ind)</code></pre>
</details>
</dd>
<dt id="ctrlstrct_run.create_ontology_tbox"><code class="name flex">
<span>def <span class="ident">create_ontology_tbox</span></span>(<span>) ‑> ontology</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new ontology that does not overlap ony other Owlready2 ontology
and fill it with static definitions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_ontology_tbox() -&gt; &#34;ontology&#34;:
    &#34;&#34;&#34;Create a new ontology that does not overlap ony other Owlready2 ontology
    and fill it with static definitions&#34;&#34;&#34;
    # create an ontology
    onto = get_isolated_ontology(ONTOLOGY_IRI)
    clear_ontology(onto, keep_tbox=False)

    with onto:
        # fill ontology wit static definitions
        init_persistent_structure(onto)
    return onto</code></pre>
</details>
</dd>
<dt id="ctrlstrct_run.extact_mistakes"><code class="name flex">
<span>def <span class="ident">extact_mistakes</span></span>(<span>onto, as_objects=False, group_by=('text_line',), filter_by_level=False) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Searches for instances of trace_error class and constructs a dict of the following form:
<code>"&lt;error_instance1_name&gt;": {
"classes": ["list", "of", "class", "names", ...],
"explanations": ["list", "of", "messages", ...],
"&lt;property1_name&gt;": ["list", "of", "property", "values", ...],
"&lt;property2_name&gt;": [onto.iri_1, "reference", "can present", "too", ...],
...
},
"&lt;error_instance2_name&gt;": {},
...</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extact_mistakes(onto, as_objects=False, group_by=(&#34;text_line&#34;,), filter_by_level=False) -&gt; dict:
    &#34;&#34;&#34;Searches for instances of trace_error class and constructs a dict of the following form:
        ```&#34;&lt;error_instance1_name&gt;&#34;: {
            &#34;classes&#34;: [&#34;list&#34;, &#34;of&#34;, &#34;class&#34;, &#34;names&#34;, ...],
            &#34;explanations&#34;: [&#34;list&#34;, &#34;of&#34;, &#34;messages&#34;, ...],
            &#34;&lt;property1_name&gt;&#34;: [&#34;list&#34;, &#34;of&#34;, &#34;property&#34;, &#34;values&#34;, ...],
            &#34;&lt;property2_name&gt;&#34;: [onto.iri_1, &#34;reference&#34;, &#34;can present&#34;, &#34;too&#34;, ...],
            ...
        },
        &#34;&lt;error_instance2_name&gt;&#34;: {},
        ...```

     &#34;&#34;&#34;
    error_classes = onto.Erroneous.descendants()  # a set of the descendant Classes (including self)

    properties_to_extract = (
        &#34;id&#34;, &#34;name&#34;, onto.precursor, onto.cause, onto.should_be, onto.should_be_before, onto.should_be_after,
        onto.context_should_be, onto.text_line,)

    # remove absent properties
    group_by = [pnm for pnm in group_by if onto[pnm]]
    # set default if empty so far
    group_by = group_by or (&#34;name&#34;,)

    def inst_keys(inst):
        values = []
        for prop_name in group_by:
            values.append(getattr(inst, prop_name) if hasattr(inst, prop_name) else None)
        return tuple(values)

    if filter_by_level:
        categories = [
            onto.UpcomingNeighbour,
            onto.WrongCondNeighbour,
            onto.NotNeighbour,
            onto.Erroneous
        ]
    else:
        categories = [onto.Erroneous]

    mistakes = {}

    for error_class in categories:
        # The .instances() class method can be used to iterate through all Instances of a Class (including its subclasses). It returns a generator.
        for inst in set(error_class.instances()):

            ###
            print(&#34;Erroneous instance:&#34;, inst.name)
            key = inst_keys(inst)
            d = mistakes.get(key, {})
            mistakes[key] = d

            for prop in properties_to_extract:
                values = []
                # fill values ...
                if isinstance(prop, str):
                    prop_name = prop
                    values.append(getattr(inst, prop_name))
                else:
                    prop_name = prop.name
                    for s, o in prop.get_relations():
                        if s == inst:
                            if not as_objects:
                                o = o.name if hasattr(o, &#34;name&#34;) else o
                            values.append(o)

                d[prop_name] = values

            classes = get_leaf_classes((set(inst.is_a) | set(d.get(&#34;classes&#34;, {}))) &amp; error_classes)
            d[&#34;classes&#34;] = [class_.name for class_ in classes]
            expanded_explanations = format_explanation(onto, inst)
            explanations = [d[&#34;explanation&#34;] for d in expanded_explanations]
            d[&#34;explanations&#34;] = sorted(set(d.get(&#34;explanations&#34;, []) + explanations))
            d[&#34;mistakes&#34;] = expanded_explanations
        if mistakes:
            break

    return mistakes</code></pre>
</details>
</dd>
<dt id="ctrlstrct_run.find_by_type"><code class="name flex">
<span>def <span class="ident">find_by_type</span></span>(<span>dict_or_list, types=(&lt;class &#x27;dict&#x27;&gt;,))</span>
</code></dt>
<dd>
<div class="desc"><p>plain list of dicts or objects of specified type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_by_type(dict_or_list, types=(dict,), _not_entry=None):
    &#34;&#34;&#34;plain list of dicts or objects of specified type&#34;&#34;&#34;
    _not_entry = _not_entry or set()
    if isinstance(dict_or_list, types):
        yield dict_or_list
        _not_entry.add(id(dict_or_list))
    if isinstance(dict_or_list, dict):
        for v in dict_or_list.values():
            if id(v) not in _not_entry:
                yield from find_by_type(v, types, _not_entry)
    elif isinstance(dict_or_list, (list, tuple, set)):
        for v in dict_or_list:
            if id(v) not in _not_entry:
                yield from find_by_type(v, types, _not_entry)</code></pre>
</details>
</dd>
<dt id="ctrlstrct_run.init_persistent_structure"><code class="name flex">
<span>def <span class="ident">init_persistent_structure</span></span>(<span>onto)</span>
</code></dt>
<dd>
<div class="desc"><p>Fill ontology with static definitions (RDF/OWL classes and properties)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_persistent_structure(onto):
    &#34;&#34;&#34;Fill ontology with static definitions (RDF/OWL classes and properties)&#34;&#34;&#34;
    skos = onto.get_namespace(&#34;http://www.w3.org/2004/02/skos/core#&#34;)

    with onto:
        # Статические определения

        # use shortcut instead of adding unnecessary class
        Concept = Thing

        if WRITE_CONCEPT_FLAG_LABEL:
            # skos:broader  (has broader, is sub-concept-of)
            class broader(AnnotationProperty):
                namespace = skos

        # annotation `has_bitflags`
        class has_bitflags(AnnotationProperty):
            &#34;&#34;&#34;a Concept can have label &amp; flags &#34;&#34;&#34;

        FLAGS_visible = 1
        FLAGS_target = 2

        # new property: id
        if not onto[&#34;id&#34;]:
            id_prop = types.new_class(&#34;id&#34;, (Thing &gt;&gt; int, FunctionalProperty,))

        # -&gt;
        class act(Concept):
            pass

        # --&gt;
        class act_begin(act):
            pass

        # ---&gt;
        class trace(act_begin):
            pass

        if WRITE_CONCEPT_FLAG_LABEL:
            trace.has_bitflags = 0 | FLAGS_target;
            trace.label = [&#39;execution trace&#39;]

        # --&gt;
        class act_end(act):
            pass

        # --&gt;
        class implicit_act(act):
            &#34;&#34;&#34;act that skipped by student but added instead by rules&#34;&#34;&#34;

        class finish_trace_act(act):
            &#39;&#39;&#39;class that marks an act;
            if an act with this class present,
            the trace can be automatically closed with &#34;program ended&#34;.&#39;&#39;&#39;

        # --&gt;
        class correct_act(act):
            pass

        # # --&gt;
        class normal_flow_correct_act(correct_act):
            pass

        # hide so far
        # class breaking_flow_correct_act(correct_act): pass
        # AllDisjoint([
        #   normal_flow_correct_act,
        #   breaking_flow_correct_act
        # ])

        # -&gt;
        class linked_list(Thing):
            pass

        # -&gt;
        class action(Concept):
            pass

        # annotation `atom_action`
        class atom_action(AnnotationProperty):
            &#34;&#34;&#34;action that is is atomic and always shown in &#39;performed&#39; phase &#34;&#34;&#34;

        class algorithm(Concept):
            pass

        class entry_point(algorithm &gt;&gt; action, FunctionalProperty):
            pass

        class boundary(Thing):
            &#34;&#34;&#34;A node of actual execution graph &#34;&#34;&#34;
            pass  # begin or end of an action

        class boundary_of(boundary &gt;&gt; action, FunctionalProperty):
            pass

        class begin_of(boundary_of):
            pass

        class end_of(boundary_of):
            pass

        class halt_of(boundary_of):
            pass  # interrupted_end_of

        class interrupt_origin(boundary &gt;&gt; boundary):
            pass

        # annotation `act_class`
        class act_class(AnnotationProperty):
            &#34;&#34;&#34;boundary_of property class -&gt; act_begin or act_end&#34;&#34;&#34;
            pass

        begin_of.act_class = act_begin
        end_of.act_class = act_end
        halt_of.act_class = act_end

        # helper
        class gathered_child_exec_till(act &gt;&gt; act):
            pass

        # helper
        class gather_child_exec_till(gathered_child_exec_till):
            pass

        # helper
        class child_executes(act &gt;&gt; boundary):
            pass

        # new property: consequent - ребро графа переходов, заменяющего правильную трассу
        class consequent(Thing &gt;&gt; Thing, ):
            pass

        # vicinity - the immediate future, before the condition
        class has_upcoming(boundary &gt;&gt; boundary, TransitiveProperty):
            pass

        # consecutive boundaries of the same type (start or end =&gt; end_of or halt_of)
        class collapse_bound(boundary &gt;&gt; boundary, TransitiveProperty):
            pass

        # class interrupting_consequent(consequent): pass
        # + subclasses
        class normal_consequent(consequent):
            pass

        class always_consequent(normal_consequent, has_upcoming):
            pass

        class on_true_consequent(normal_consequent):
            pass

        class on_false_consequent(normal_consequent):
            pass

        # -&gt;
        class sequence(action):
            pass

        if WRITE_CONCEPT_FLAG_LABEL:
            sequence.has_bitflags = 0
            sequence.label = &#39;последовательность&#39;

        # признак first
        class first_item(Thing, ):
            pass

        # признак last
        class last_item(Thing, ):
            pass

        # индекс в списке
        class item_index(Thing &gt;&gt; int, FunctionalProperty):
            pass

        # -&gt;
        class loop(action):
            pass

        if WRITE_CONCEPT_FLAG_LABEL:
            loop.has_bitflags = FLAGS_visible | FLAGS_target;
            loop.label = [&#39;Циклы&#39;]

        if loop:  # hide a block under code folding
            # classes that regulate the use of condition in a loop

            # normal condition effect (false-&gt;stop, true-&gt;start a body) like in while, do-while, for loop types
            class conditional_loop(loop):
                pass

            # no condition at all: infinite loop like while(true){...}. The only act endlessly executed is the loop body.
            class unconditional_loop(loop):
                pass

            # # inverse condition effect (false-&gt;start a body, true-&gt;stop) like in do-until loop
            # inverse_conditional_loop = types.new_class(&#34;inverse_conditional_loop&#34;, (loop,))

            # The constraint is not useful so far
            # AllDisjoint([conditional_loop, unconditional_loop])

            class infinite_loop(unconditional_loop):
                pass

            class ntimes_loop(unconditional_loop):
                pass

            # classes that regulate a loop execution start (which act should be first)
            #
            # start with cond
            class start_with_cond(conditional_loop):
                pass

            # start with body
            class start_with_body(loop):
                pass

            # start with init
            class start_with_init(conditional_loop):
                pass

            # The constraint is not useful so far
            # AllDisjoint([start_with_cond, start_with_body, start_with_init])

            # classes that regulate the use of &#34;update&#34; step in a for-like loop
            # (both subclasses of &#34;loop_with_initialization&#34; as that loop have &#34;update&#34; step too)
            #
            # update first, then the body, like in foreach loop type
            class pre_update_loop(conditional_loop):
                pass

            # body first, then the update, like in for(;;) loop type
            class post_update_loop(conditional_loop):
                pass

            AllDisjoint([pre_update_loop, post_update_loop])

            # classes that indicate whether condition and body follow each other instantly or not
            # (note that: these classes are not disjointed; these classes are to be inferred from another defined features via equivalent_to definition so no direct inheritance required for known loops)
            # class body_then_cond(loop):
            #     equivalent_to = [inverse_conditional_loop | (conditional_loop &amp; (Not(post_update_loop)))]
            # class cond_then_body(loop):
            #     equivalent_to = [conditional_loop &amp; (Not(pre_update_loop))]

            # workaround: do not use the inference, declare explicitly
            class cond_then_body(conditional_loop):
                pass

            class body_then_cond(conditional_loop):
                pass

            # classes that define well-known loops as subclasses of the above defined loop-feature classes.
            # These classes are to be used publicly
            class while_loop(start_with_cond):
                pass

            while_loop.is_a += [cond_then_body, body_then_cond]  # workaround
            while_loop.label = [&#34;WHILE&#34;]

            if WRITE_CONCEPT_FLAG_LABEL:
                while_loop.has_bitflags = FLAGS_visible | FLAGS_target;
                while_loop.broader = [loop]

            class do_while_loop(start_with_body):
                pass

            do_while_loop.is_a += [cond_then_body, body_then_cond]  # workaround
            do_while_loop.label = [&#34;DO-WHILE&#34;]

            if WRITE_CONCEPT_FLAG_LABEL:
                do_while_loop.has_bitflags = FLAGS_visible | FLAGS_target;
                do_while_loop.broader = [loop]

            # class do_until_loop(inverse_conditional_loop, postconditional_loop): pass
            # do_until_loop.is_a += [body_then_cond]  # workaround
            # do_until_loop.label = [&#34;DO-UNTIL&#34;]

            class for_loop(post_update_loop, start_with_init):
                pass

            for_loop.is_a += [cond_then_body]  # workaround
            for_loop.label = [&#34;FOR&#34;]

            if WRITE_CONCEPT_FLAG_LABEL:
                for_loop.has_bitflags = FLAGS_visible | FLAGS_target;
                for_loop.broader = [loop]

            class foreach_loop(pre_update_loop, start_with_cond):
                pass

            foreach_loop.is_a += [body_then_cond]  # workaround
            foreach_loop.label = [&#34;FOREACH&#34;]

            # if WRITE_CONCEPT_FLAG_LABEL:
            #     foreach_loop.has_bitflags = FLAGS_visible | FLAGS_target;
            #     foreach_loop.broader = [loop]

        # --&gt;
        class alt_branch(sequence):
            pass

        # if WRITE_CONCEPT_FLAG_LABEL:
        #     alt_branch.has_bitflags = FLAGS_visible | FLAGS_target;
        #     alt_branch.label = [&#39;Ветки развилки&#39;]

        class func(action):
            pass

        # class func(sequence): pass
        class alternative(action):
            pass

        if WRITE_CONCEPT_FLAG_LABEL:
            alternative.has_bitflags = FLAGS_visible | FLAGS_target;
            alternative.label = [&#39;if&#39;]

        for class_name in [
            &#34;if&#34;, &#34;else-if&#34;, &#34;else&#34;,
        ]:
            cls = types.new_class(class_name, (alt_branch,))
            if WRITE_CONCEPT_FLAG_LABEL:
                cls.has_bitflags = FLAGS_visible | FLAGS_target;
                cls.label = [class_name]
        if WRITE_CONCEPT_FLAG_LABEL:
            onto[&#34;if&#34;].has_bitflags = 0 | FLAGS_target;
            onto[&#34;if&#34;].broader = [alternative]
            onto[&#34;else-if&#34;].broader = [alternative]
            onto[&#34;else&#34;].broader = [alternative]

        for class_name in [
            &#34;expr&#34;, &#34;stmt&#34;, &#34;interrupt_action&#34;,
        ]:
            cls = types.new_class(class_name, (action,))
            cls.atom_action = True

        for class_name in [
            &#34;return&#34;, &#34;break&#34;, &#34;continue&#34;,  # have optional `interrupt_target`
        ]:
            cls = types.new_class(class_name, (onto[&#39;interrupt_action&#39;],))
            # add annotation name: rdfs:label
            cls.label = [class_name]
            cls.atom_action = True
            if WRITE_CONCEPT_FLAG_LABEL:
                cls.has_bitflags = FLAGS_visible | FLAGS_target;
        if WRITE_CONCEPT_FLAG_LABEL:
            # making schema for export
            class loop_break_continue(Thing): pass

            loop_break_continue.has_bitflags = FLAGS_visible | FLAGS_target;
            loop_break_continue.label = [&#39;Прерывание цикла&#39;]
            # loop_break_continue.label = [&#39;break &amp; continue&#39;]

            onto[&#34;break&#34;].broader = [loop_break_continue]
            onto[&#34;continue&#34;].broader = [loop_break_continue]

        # make some properties
        for prop_name in (&#34;body&#34;, &#34;cond&#34;, &#34;init&#34;, &#34;update&#34;, &#34;wrong_next_act&#34;, &#34;interrupt_target&#34;,):
            if not onto[prop_name]:
                types.new_class(prop_name, (Thing &gt;&gt; Thing,))

        # new property: executes
        prop_executes = types.new_class(&#34;executes&#34;, (Thing &gt;&gt; Thing, FunctionalProperty,))

        class executes_id(act &gt;&gt; int, FunctionalProperty):
            pass

        # new property: expr_value
        prop_expr_value = types.new_class(&#34;expr_value&#34;, (DataProperty, FunctionalProperty,))

        # new property: stmt_name
        prop_stmt_name = types.new_class(&#34;stmt_name&#34;, (Thing &gt;&gt; str, DataProperty, FunctionalProperty))

        # new property: next
        types.new_class(&#34;next&#34;, (Thing &gt;&gt; Thing,))
        types.new_class(&#34;next_act&#34;, (correct_act &gt;&gt; correct_act, FunctionalProperty, InverseFunctionalProperty))

        # new property: student_next
        types.new_class(&#34;student_next&#34;, (act &gt;&gt; Thing,))
        types.new_class(&#34;student_next_latest&#34;, (act &gt;&gt; act, onto.student_next))

        types.new_class(&#34;_insert_act_executing&#34;, (act &gt;&gt; boundary,))

        # new property: next_sibling -- binds acts adjacent to the execution time number
        # (with the start and end acts separated)
        next_sibling = types.new_class(&#34;next_sibling&#34;, (Thing &gt;&gt; Thing,))

        # new property: before
        # prop_before = types.new_class(&#34;before&#34;, (Thing &gt;&gt; Thing, TransitiveProperty))

        # new property: in_trace
        prop_in_trace = types.new_class(&#34;in_trace&#34;, (act &gt;&gt; trace,))

        # свойство index
        types.new_class(&#34;index&#34;, (Thing &gt;&gt; int, FunctionalProperty,))
        types.new_class(&#34;student_index&#34;, (Thing &gt;&gt; int, FunctionalProperty,))
        # номер итерации
        types.new_class(&#34;student_iteration_n&#34;, (act &gt;&gt; int, FunctionalProperty,))
        types.new_class(&#34;iteration_n&#34;, (act &gt;&gt; int, FunctionalProperty,))

        types.new_class(&#34;after_act&#34;, (Thing &gt;&gt; act,))

        # new property: exec_time
        prop_exec_time = types.new_class(&#34;exec_time&#34;, (Thing &gt;&gt; int, FunctionalProperty,))

        # new property: depth
        class depth(Thing &gt;&gt; int, FunctionalProperty, ):
            pass

        # # new property: correct_depth
        # prop_correct_depth = types.new_class(&#34;correct_depth&#34;, (Thing &gt;&gt; int, FunctionalProperty, ))

        # new property: text_line
        prop_text_line = types.new_class(&#34;text_line&#34;, (Thing &gt;&gt; int, FunctionalProperty,))

        # make string_placeholder properties
        class string_placeholder(Thing &gt;&gt; str):
            pass

        for suffix in (
                &#34;A&#34;,  # &#34;B&#34;, &#34;C&#34;, &#34;D&#34;, &#34;EX&#34;,
                &#34;A_bound&#34;,
                &#34;kind_of_loop&#34;,
                &#34;kind_of_action&#34;,
                &#34;TrueFalse&#34;,
                &#34;BEGIN&#34;,  # для CorrespondingEndMismatched
                &#34;EXTRA&#34;,  # для NotNeighbour
                # &#34;EXTRA_act&#34;,
                &#34;EXTRA_bound&#34;,  # &lt;-- ObjectProperty!
                &#34;MISSING&#34;,  # omitted before the current
                # &#34;MISSING_act&#34;,
                &#34;MISSING_bound&#34;,  # &lt;-- ObjectProperty!
                &#34;COND&#34;,  # any condition (general case)
                &#34;INNER&#34;,
                # для CorrespondingEndMismatched: A non-conforming beginning, which is the embedded action of a non-conforming end
                &#34;CONTEXT&#34;,  # (Incorrect) parent (on the trace)
                &#34;PARENT&#34;,  # correct parent
                &#34;PREVIOUS&#34;,  # TooLateInSequence: the one that should be after, but it is before the current one
                &#34;LOOP&#34;,
                &#34;LOOP_COND&#34;,
                &#34;INIT&#34;,
                &#34;UPDATE&#34;,
                &#34;ALT&#34;,
                &#34;ALT_COND&#34;,  # any of the conditions (lists all the conditions)
                &#34;CURRENT_ALT_COND&#34;,  # current condition
                # &#34;PREV_ALT_COND&#34;,
                &#34;LATEST_ALT_COND&#34;,  # performed last, but not the current condition
                &#34;EXPECTED_ALT_COND&#34;,  # expected but absent
                &#34;REQUIRED_COND&#34;,  # a condition that has not been calculated
                &#34;UNEXPECTED_ALT_COND&#34;,  # not expected, but present
                &#34;BRANCH&#34;,  # has already been calculated
                &#34;BRANCH2&#34;,
                &#34;EXPECTED_BRANCH&#34;, &#34;UNEXPECTED_BRANCH&#34;,
                &#34;SEQ&#34;,
                &#34;NEXT&#34;,
                &#34;NEXT_COND&#34;,
        ):
            prop_name = &#34;field_&#34; + suffix
            if not onto[prop_name]:
                prop_class_ = string_placeholder
                if not WRITE_INVOLVES_CONCEPT and suffix.endswith((&#39;_act&#39;, &#39;_bound&#39;)):
                    prop_class_ = ObjectProperty
                types.new_class(prop_name, (prop_class_,))

        class fetch_kind_of_loop(act &gt;&gt; action, ):
            pass

        class reason_kind(boundary &gt;&gt; Thing, ):
            pass

        class to_reason(Thing &gt;&gt; Thing, ):
            pass

        class from_reason(Thing &gt;&gt; Thing, ):
            pass

        # new property: corresponding_end
        class corresponding_end(act_begin &gt;&gt; act_end, ):
            pass

        class student_corresponding_end(act_begin &gt;&gt; act_end, ):
            pass

        class hasPartTransitive(Thing &gt;&gt; Thing, TransitiveProperty):
            pass

        # new property: parent_of
        class parent_of(hasPartTransitive, InverseFunctionalProperty):
            pass

        class student_parent_of(Thing &gt;&gt; Thing, InverseFunctionalProperty):
            pass

        class branches_item(parent_of):
            pass

        class body(parent_of):
            pass

        class body_item(parent_of):
            pass

        # объекты, спровоцировавшие ошибку
        if not onto[&#34;Erroneous&#34;]:
            Erroneous = types.new_class(&#34;Erroneous&#34;, (Thing,))

            # category2priority = None  # declare it later
            # class error_priority(Thing &gt;&gt; int): pass

            # class-level properties (called Annotations)
            class involves_concept(AnnotationProperty):
                pass

            class principal_violation(AnnotationProperty):
                pass

            # reason node can be associated with violations poassible at the step of solution
            class possible_violation(ObjectProperty):
                pass

            # make Erroneous subclasses
            # (class, [bases])
            for class_spec in [
                # (name, [bases], err_level, {related, concepts})

                # Sequence mistakes ...
                (&#34;CorrespondingEndMismatched&#34;, (), &#34;trace_structure&#34;, {&#39;action&#39;}),
                (&#34;WrongNext&#34;, (), &#34;general_wrong&#34;, {&#39;action&#39;}),

                # &#34;CorrespondingEndPerformedDifferentTime&#34;,
                # &#34;WrongExecTime&#34;,
                # &#34;ActStartsAfterItsEnd&#34;, &#34;ActEndsWithoutStart&#34;,
                # &#34;AfterTraceEnd&#34;,
                # &#34;DuplicateActInSequence&#34;,
                (&#34;ConditionMisuse&#34;, [&#34;WrongNext&#34;], &#34;general_wrong&#34;, {&#39;expr&#39;}),

                (&#34;WrongContext&#34;, (), &#34;wrong_context&#34;, {&#39;action&#39;}),
                # (&#34;MisplacedBefore&#34;, [&#34;WrongContext&#34;]),
                # (&#34;MisplacedAfter&#34;, [&#34;WrongContext&#34;]),
                (&#34;MisplacedDeeper&#34;, [&#34;WrongContext&#34;], &#34;wrong_context&#34;, {&#39;action&#39;}),
                (&#34;EndedDeeper&#34;, [&#34;WrongContext&#34;, ], &#34;wrong_context&#34;, {&#39;action&#39;}),  # +
                (&#34;EndedShallower&#34;, [&#34;WrongContext&#34;, &#34;CorrespondingEndMismatched&#34;], &#34;wrong_context&#34;, {&#39;action&#39;}),
                # не возникнет для первой ошибки в трассе.
                (&#34;OneLevelShallower&#34;, [&#34;WrongContext&#34;], &#34;concrete_wrong_context&#34;, {&#39;action&#39;}),  # +

                (&#34;NeighbourhoodError&#34;, [&#34;WrongNext&#34;], &#34;general_wrong&#34;, {&#39;action&#39;}),
                # check that one of the following is determined
                (&#34;UpcomingNeighbour&#34;, [&#34;NeighbourhoodError&#34;], &#34;missing&#34;, {&#39;action&#39;}),  #
                (&#34;NotNeighbour&#34;, [&#34;NeighbourhoodError&#34;], &#34;extra&#34;, {&#39;action&#39;}),  # disjoint with UpcomingNeighbour
                (&#34;WrongCondNeighbour&#34;, [&#34;NotNeighbour&#34;, &#34;ConditionMisuse&#34;], &#34;by_different_cond&#34;, {&#39;action&#39;}),  #

                # interrupted flow
                (&#34;UnexpectedWhenInterrupting&#34;, [&#34;NotNeighbour&#34;, ], &#34;extra&#34;, {&#39;action&#39;}),  #
                (&#34;TooEarlyWhenInterrupting&#34;, [&#34;UpcomingNeighbour&#34;, ], &#34;missing&#34;, {&#39;action&#39;}),  #
                (&#34;IgnoreInterruptingFlow&#34;, [&#34;UnexpectedWhenInterrupting&#34;, ], &#34;extra&#34;, {&#39;action&#39;}),  #

                # (&#34;ExtraAct&#34;, [&#34;WrongNext&#34;]),
                (&#34;DuplicateOfAct&#34;, [], &#34;extra&#34;, {&#39;sequence&#39;}),
                # &#34;MissingAct&#34;,
                # &#34;TooEarly&#34;, # right after missing acts
                # (&#34;DisplacedAct&#34;, [&#34;TooEarly&#34;,&#34;ExtraAct&#34;,&#34;MissingAct&#34;]), # act was moved somewhere
                (&#34;TooLateInSequence&#34;, [&#34;WrongNext&#34;], &#34;extra&#34;, {&#39;sequence&#39;}),  # +
                (&#34;TooEarlyInSequence&#34;, [&#34;WrongNext&#34;], &#34;missing&#34;, {&#39;sequence&#39;}),  # +
                (&#34;SequenceFinishedNotInOrder&#34;, (), &#34;extra&#34;, {&#39;sequence&#39;}),
                # выполнены все действия, но в конце не последнее; не возникнет для первой ошибки в трассе.
                (&#34;SequenceFinishedTooEarly&#34;, [&#34;SequenceFinishedNotInOrder&#34;], &#34;missing&#34;, {&#39;sequence&#39;}),  # +

                # Alternatives mistakes ...
                (&#34;NoFirstCondition&#34;, (), &#34;missing&#34;, {&#39;alternative&#39;, &#39;if&#39;, &#39;expr&#39;}),  # +
                (&#34;NoAlternativeEndAfterBranch&#34;, (), &#34;missing&#34;, {&#39;alternative&#39;, &#39;alt_branch&#39;}),  # +
                (&#34;CondtionNotNextToPrevCondition&#34;, (), &#34;extra&#34;, {&#39;alternative&#39;, &#39;else-if&#39;, &#39;expr&#39;}),  # +
                (&#34;ConditionAfterBranch&#34;, [&#34;NoAlternativeEndAfterBranch&#34;, &#34;CondtionNotNextToPrevCondition&#34;], &#34;extra&#34;,
                 {&#39;alternative&#39;, &#39;alt_branch&#39;, &#39;expr&#39;}),  # ~
                (&#34;DuplicateOfCondition&#34;, [&#34;CondtionNotNextToPrevCondition&#34;, &#34;ConditionAfterBranch&#34;], &#34;extra&#34;,
                 {&#39;alternative&#39;, &#39;if&#39;, &#39;else-if&#39;, &#39;expr&#39;}),  # +
                # (&#34;WrongBranch&#34;, [&#34;ExtraAct&#34;]),
                (&#34;BranchOfFalseCondition&#34;, [&#34;ConditionMisuse&#34;], &#34;by_different_cond&#34;,
                 {&#39;alternative&#39;, &#39;alt_branch&#39;, &#39;expr&#39;}),
                (&#34;AnotherExtraBranch&#34;, [&#34;NoAlternativeEndAfterBranch&#34;], &#34;extra&#34;, {&#39;alternative&#39;, &#39;alt_branch&#39;}),  # +
                (&#34;BranchWithoutCondition&#34;, (), &#34;extra&#34;, {&#39;alternative&#39;, &#39;alt_branch&#39;, &#39;expr&#39;}),  # +
                (&#34;BranchNotNextToCondition&#34;, [&#34;BranchWithoutCondition&#34;], &#34;missing&#34;,
                 {&#39;alternative&#39;, &#39;alt_branch&#39;, &#39;expr&#39;}),  # +
                (&#34;ElseBranchNotNextToLastCondition&#34;, [&#34;BranchWithoutCondition&#34;], &#34;extra&#34;,
                 {&#39;alternative&#39;, &#39;alt_branch&#39;, &#39;else&#39;, &#39;expr&#39;}),  # +
                (&#34;ElseBranchAfterTrueCondition&#34;,
                 [&#34;BranchWithoutCondition&#34;, &#34;ElseBranchNotNextToLastCondition&#34;, &#34;ConditionMisuse&#34;], &#34;by_different_cond&#34;,
                 {&#39;alternative&#39;, &#39;alt_branch&#39;, &#39;else&#39;, &#39;expr&#39;}),  # ~
                (&#34;NoBranchWhenConditionIsTrue&#34;, [&#34;ConditionMisuse&#34;], &#34;by_different_cond&#34;,
                 {&#39;alternative&#39;, &#39;alt_branch&#39;, &#39;expr&#39;}),  # +
                (&#34;LastConditionIsFalseButNoElse&#34;, (), &#34;missing&#34;, {&#39;alternative&#39;, &#39;alt_branch&#39;, &#39;else&#39;, &#39;expr&#39;}),  # +
                (&#34;NoNextCondition&#34;, (), &#34;missing&#34;, {&#39;alternative&#39;, &#39;expr&#39;}),  # ~
                (&#34;ConditionTooLate&#34;, [&#34;NoNextCondition&#34;, &#34;CondtionNotNextToPrevCondition&#34;], &#34;extra&#34;,
                 {&#39;alternative&#39;, &#39;expr&#39;}),  # - skip for now
                (
                        &#34;ConditionTooEarly&#34;, [&#34;NoFirstCondition&#34;, &#34;NoNextCondition&#34;, &#34;CondtionNotNextToPrevCondition&#34;],
                        &#34;extra&#34;,
                        {&#39;alternative&#39;, &#39;expr&#39;}),  # +
                (&#34;LastFalseNoEnd&#34;, (), &#34;missing&#34;, {&#39;alternative&#39;, &#39;expr&#39;}),  # +
                (&#34;AlternativeEndAfterTrueCondition&#34;, [&#34;ConditionMisuse&#34;], &#34;by_different_cond&#34;,
                 {&#39;alternative&#39;, &#39;alt_branch&#39;, &#39;expr&#39;}),  # +

                # Loops mistakes ...
                # a general Loop
                (&#34;NoLoopEndAfterFailedCondition&#34;, (), &#34;missing&#34;, {&#39;loop&#39;, &#39;expr&#39;}),  # +
                (&#34;LoopContinuedAfterFailedCondition&#34;, [&#34;NoLoopEndAfterFailedCondition&#34;, &#34;ConditionMisuse&#34;],
                 &#34;by_different_cond&#34;, {&#39;loop&#39;, &#39;expr&#39;}),  # +
                (&#34;IterationAfterFailedCondition&#34;, [&#34;LoopContinuedAfterFailedCondition&#34;], &#34;extra&#34;, {&#39;loop&#39;, &#39;expr&#39;}),
                # +
                (&#34;LoopEndsWithoutCondition&#34;, (), &#34;extra&#34;, {&#39;loop&#39;, &#39;expr&#39;}),  # +
                # start_with_cond
                (&#34;LoopStartIsNotCondition&#34;, (), &#34;missing&#34;, {&#39;while_loop&#39;, &#39;expr&#39;}),  # +
                # start_with_body
                (&#34;LoopStartIsNotIteration&#34;, (), &#34;missing&#34;, {&#39;do_while_loop&#39;}),  # +
                # cond_then_body (-&gt; true)
                (&#34;NoIterationAfterSuccessfulCondition&#34;, (), &#34;missing&#34;,
                 {&#39;while_loop&#39;, &#39;do_while_loop&#39;, &#39;for_loop&#39;, &#39;expr&#39;}),  # +
                (&#34;LoopEndAfterSuccessfulCondition&#34;, [&#34;NoIterationAfterSuccessfulCondition&#34;, &#34;ConditionMisuse&#34;],
                 &#34;by_different_cond&#34;, {&#39;while_loop&#39;, &#39;do_while_loop&#39;, &#39;for_loop&#39;, &#39;expr&#39;}),  # +
                # body_then_cond
                (&#34;NoConditionAfterIteration&#34;, (), &#34;missing&#34;, {&#39;while_loop&#39;, &#39;do_while_loop&#39;, &#39;expr&#39;}),  # +
                (&#34;NoConditionBetweenIterations&#34;, [&#34;NoConditionAfterIteration&#34;], &#34;missing&#34;,
                 {&#39;while_loop&#39;, &#39;do_while_loop&#39;, &#39;expr&#39;}),  # +
                # ForLoop
                (&#34;LoopStartsNotWithInit&#34;, (), &#34;missing&#34;, {&#39;for_loop&#39;, }),
                (&#34;InitNotAtLoopStart&#34;, (), &#34;extra&#34;, {&#39;for_loop&#39;, }),
                (&#34;NoConditionAfterForInit&#34;, (), &#34;missing&#34;, {&#39;for_loop&#39;, &#39;expr&#39;}),
                (&#34;IterationAfterForInit&#34;, [&#34;NoConditionAfterForInit&#34;], &#34;extra&#34;, {&#39;for_loop&#39;, }),
                (&#34;NoUpdateAfterIteration&#34;, (), &#34;missing&#34;, {&#39;for_loop&#39;, }),
                (&#34;UpdateNotAfterIteration&#34;, (), &#34;extra&#34;, {&#39;for_loop&#39;, }),
                (&#34;ForConditionAfterIteration&#34;, [&#34;UpdateNotAfterIteration&#34;], &#34;extra&#34;, {&#39;for_loop&#39;, &#39;expr&#39;}),
                (&#34;NoConditionAfterForUpdate&#34;, (), &#34;missing&#34;, {&#39;for_loop&#39;, }),
                # ForeachLoop
                (&#34;NoForeachUpdateAfterSuccessfulCondition&#34;, (), &#34;missing&#34;, {&#39;foreach_loop&#39;, }),
                (&#34;ForeachUpdateNotAfterSuccessfulCondition&#34;, (), &#34;extra&#34;, {&#39;foreach_loop&#39;, }),
                (&#34;NoIterationAfterForeachUpdate&#34;, (), &#34;missing&#34;, {&#39;foreach_loop&#39;, }),
                (&#34;IterationNotAfterForeachUpdate&#34;, (), &#34;extra&#34;, {&#39;foreach_loop&#39;, }),
            ]:
                if isinstance(class_spec, str):
                    types.new_class(class_spec, (Erroneous,))
                elif isinstance(class_spec, tuple):
                    class_name, base_names = class_spec[:2]
                    bases = tuple(
                        (onto[base_name] if type(base_name) is str else base_name) for base_name in base_names)
                    created_class = types.new_class(class_name, bases or (Erroneous,))
                    if WRITE_INVOLVES_CONCEPT:
                        related_concepts = class_spec[3]
                        created_class.involves_concept = list(map(onto.__getattr__, sorted(related_concepts)))

        for prop_name in (
                &#34;precursor&#34;, &#34;cause&#34;, &#34;has_causing_condition&#34;, &#34;should_be&#34;, &#34;should_be_before&#34;, &#34;should_be_after&#34;,
                &#34;context_should_be&#34;):
            if not onto[prop_name]:
                types.new_class(prop_name, (onto[&#34;Erroneous&#34;] &gt;&gt; Thing,))

        # make consequent subproperties (always_consequent is default base)
        for class_spec in [
            #: (name, optional base, [principal_violations])
            # &#34;FunctionBegin&#34;,
            # &#34;FunctionEnd&#34;,
            # &#34;FunctionBodyBegin&#34;,
            &#34;StmtEnd&#34;,
            &#34;ExprEnd&#34;,

            (&#34;Interrupted&#34;, 0, []),  # [??]
            (&#34;GlobalCodeBegin&#34;, 0, [&#39;TooEarlyInSequence&#39;, &#39;SequenceFinishedTooEarly&#39;]),
            (&#34;SequenceBegin&#34;, 0, [&#39;TooEarlyInSequence&#39;, &#39;SequenceFinishedTooEarly&#39;]),
            (&#34;SequenceNext&#34;, 0, [&#39;DuplicateOfAct&#39;, &#39;TooEarlyInSequence&#39;, &#39;SequenceFinishedTooEarly&#39;]),
            (&#34;SequenceEnd&#34;, 0, [&#39;DuplicateOfAct&#39;]),

            (&#34;AltBegin&#34;, 0, [&#39;NoFirstCondition&#39;]),  # 1st condition
            (&#34;AltBranchBegin&#34;, on_true_consequent, [&#39;NoBranchWhenConditionIsTrue&#39;]),
            # ElseBranchAfterTrueCondition (enabled by ELSE branch) - not included directly; see special rule from that whose process algorithms
            (&#34;NextAltCondition&#34;, on_false_consequent, [&#39;BranchOfFalseCondition&#39;]),
            (&#34;AltElseBranchBegin&#34;, on_false_consequent, [&#39;LastConditionIsFalseButNoElse&#39;, &#39;BranchOfFalseCondition&#39;]),
            (&#34;AltEndAllFalse&#34;, on_false_consequent, [&#39;LastFalseNoEnd&#39;]),
            (&#34;AltEndAfterBranch&#34;, 0, [&#39;NoAlternativeEndAfterBranch&#39;]),

            (&#34;PreCondLoopBegin&#34;, 0, [&#39;LoopStartIsNotCondition&#39;]),
            (&#34;PostCondLoopBegin&#34;, 0, [&#39;LoopStartIsNotIteration&#39;]),
            (&#34;IterationBeginOnTrueCond&#34;, on_true_consequent, [&#39;NoIterationAfterSuccessfulCondition&#39;]),
            # &#34;IterationBeginOnFalseCond&#34;,
            (&#34;LoopUpdateOnTrueCond&#34;, on_true_consequent, [&#39;NoForeachUpdateAfterSuccessfulCondition&#39;]),
            (&#34;IterationAfterUpdate&#34;, 0, [&#39;NoIterationAfterForeachUpdate&#39;]),
            (&#34;LoopEndOnFalseCond&#34;, on_false_consequent, [&#39;NoLoopEndAfterFailedCondition&#39;]),
            # &#34;LoopEndOnTrueCond&#34;,  # no rule yet?
            (&#34;LoopCondBeginAfterIteration&#34;, 0, [&#39;NoConditionAfterIteration&#39;]),
            (&#34;LoopWithInitBegin&#34;, 0, [&#39;LoopStartsNotWithInit&#39;]),
            (&#34;LoopCondBeginAfterInit&#34;, 0, [&#39;NoConditionAfterForInit&#39;]),
            (&#34;LoopUpdateAfterIteration&#34;, 0, [&#39;NoUpdateAfterIteration&#39;]),
            (&#34;LoopCondAfterUpdate&#34;, 0, [&#39;NoConditionAfterForUpdate&#39;]),
        ]:
            # types.new_class(class_name, (correct_act,))
            if isinstance(class_spec, str):
                types.new_class(class_spec, (always_consequent,))
            elif isinstance(class_spec, tuple):
                class_name, base_names = class_spec[:2]
                bases = tuple(
                    (onto[base_name] if type(base_name) is str else base_name) for base_name in [base_names] if
                    base_name)
                created_class = types.new_class(class_name, bases or (always_consequent,))
                if WRITE_PRINCIPAL_VIOLATION and len(class_spec) &gt;= 3:
                    violations = class_spec[2]
                    created_class.principal_violation = list(map(onto.__getattr__, violations))

        for prop_name in (&#34;reason&#34;,):  # for correct acts !
            if not onto[prop_name]:
                types.new_class(prop_name, (correct_act &gt;&gt; Thing,))</code></pre>
</details>
</dd>
<dt id="ctrlstrct_run.link_objects"><code class="name flex">
<span>def <span class="ident">link_objects</span></span>(<span>onto, iri_subj: str, prop_name: str, iri_obj: str, prop_superclasses=(owl.ObjectProperty,))</span>
</code></dt>
<dd>
<div class="desc"><p>Make a relation between two individuals that must exist in the ontology. The property, however, is created if does not exist (the <code>prop_superclasses</code> are applied to the new property).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def link_objects(onto, iri_subj: str, prop_name: str, iri_obj: str, prop_superclasses=(Thing &gt;&gt; Thing,)):
    &#34;&#34;&#34;Make a relation between two individuals that must exist in the ontology. The property, however, is created if does not exist (the `prop_superclasses` are applied to the new property).&#34;&#34;&#34;
    prop = onto[prop_name]
    if not prop:
        with onto:
            # new property
            prop = types.new_class(prop_name, prop_superclasses)
    make_triple(onto[iri_subj], prop, onto[iri_obj])</code></pre>
</details>
</dd>
<dt id="ctrlstrct_run.make_trace_for_algorithm"><code class="name flex">
<span>def <span class="ident">make_trace_for_algorithm</span></span>(<span>alg_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>just a wrapper for <code><a title="ctrlstrct_run.TraceTester.make_correct_trace" href="#ctrlstrct_run.TraceTester.make_correct_trace">TraceTester.make_correct_trace()</a></code> method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_trace_for_algorithm(alg_dict):
    &#34;&#34;&#34;just a wrapper for `TraceTester.make_correct_trace()` method&#34;&#34;&#34;
    try:
        trace_data = {
            &#34;algorithm&#34;: alg_dict,
            &#34;header_boolean_chain&#34;: None,
        }
        tt = TraceTester(trace_data)
        tt.prepare_id2obj()
        tt.make_correct_trace()

        # Clear alg_dict[&#34;id2obj&#34;] dictionary from recursive reference to alg_dict itself
        for key in alg_dict[&#34;id2obj&#34;]:
            if alg_dict[&#34;id2obj&#34;][key] is alg_dict:
                del alg_dict[&#34;id2obj&#34;][key]
                break

        return tt.data[&#34;correct_trace&#34;]
    except Exception as e:
        print(&#34;Error !&#34;)
        print(&#34;Error making correct_trace:&#34;)
        print(&#34; &#34;, e)
        # raise e  # useful for debugging
        return str(e)</code></pre>
</details>
</dd>
<dt id="ctrlstrct_run.prepare_name"><code class="name flex">
<span>def <span class="ident">prepare_name</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"><p>Transliterate given word (to latin chars) if needed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepare_name(s):
    &#34;&#34;&#34;Transliterate given word (to latin chars) if needed&#34;&#34;&#34;
    return slugify(s, &#34;ru&#34;) or s</code></pre>
</details>
</dd>
<dt id="ctrlstrct_run.process_algtraces"><code class="name flex">
<span>def <span class="ident">process_algtraces</span></span>(<span>trace_data_list, debug_rdf_fpath=None, verbose=1, mistakes_as_objects=False, filter_by_level=False) ‑> onto, mistakes_list</span>
</code></dt>
<dd>
<div class="desc"><p>Write number of <code>algorithm - trace</code> pair to an ontology,
perform extended reasoning and then extract and return the mistakes found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_algtraces(trace_data_list, debug_rdf_fpath=None, verbose=1,
                      mistakes_as_objects=False, filter_by_level=False,
                      _eval_max_traces=None) -&gt; &#34;onto, mistakes_list&#34;:
    &#34;&#34;&#34;Write number of `algorithm - trace` pair to an ontology,
        perform extended reasoning and then extract and return the mistakes found.
    &#34;&#34;&#34;

    if verbose: ch = Checkpointer()

    onto = create_ontology_tbox()

    if verbose: ch.hit(&#34;create ontology tbox&#34;)

    # наполняем онтологию с нуля сущностями с теми именами, которые найдём в загруженных json-словарях

    if _eval_max_traces is not None:
        # adjust the list size
        if _eval_max_traces &lt;= len(trace_data_list):
            trace_data_list = trace_data_list[0:_eval_max_traces + 1]
        else:
            from itertools import cycle
            cycled = cycle(trace_data_list)
            for trace in cycled:
                trace_data_list.append(trace)
                if len(trace_data_list) == _eval_max_traces:
                    break

    for tr_data in trace_data_list:
        tt = TraceTester(tr_data)
        tt.inject_to_ontology(onto)
        if verbose: print(end=&#34;.&#34;)

    if verbose: ch.hit(&#34;fill ontology data&#34;)

    if debug_rdf_fpath:
        onto.save(file=debug_rdf_fpath, format=&#39;rdfxml&#39;)
        print(&#34;Saved RDF file: {} !&#34;.format(debug_rdf_fpath))

    # invoke through jenaService:
    # save ontology to buffer in memory
    # TODO: check if NTRIPLES will be processed faster!
    stream = io.BytesIO()
    onto.save(file=stream, format=&#39;rdfxml&#39;)
    result_rdf_bytes = invoke_jena_reasoning_service(rdfData=stream.getvalue())

    # Clear current ontology data
    delete_ontology(onto)

    # read from byte stream
    # use isolated worlds (keep concurrent threads in mind)
    onto = get_isolated_ontology(ONTOLOGY_IRI).load(
        fileobj=io.BytesIO(result_rdf_bytes),
        reload=True, only_local=True)

    if debug_rdf_fpath:
        onto.save(file=debug_rdf_fpath + &#34;_ext.rdf&#34;, format=&#39;rdfxml&#39;)
        print(f&#34;Saved RDF file: {debug_rdf_fpath}_ext.rdf !&#34;)

    if verbose: ch.hit(&#34;reasoning completed&#34;)

    mistakes = extact_mistakes(onto, as_objects=mistakes_as_objects, filter_by_level=filter_by_level)
    if verbose: ch.hit(&#34;mistakes extracted&#34;)

    return onto, list(mistakes.values())</code></pre>
</details>
</dd>
<dt id="ctrlstrct_run.save_schema"><code class="name flex">
<span>def <span class="ident">save_schema</span></span>(<span>file_path='jena/control-flow-statements-domain-schema.rdf')</span>
</code></dt>
<dd>
<div class="desc"><p>Save ontology data (static definitions only) as RDF file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_schema(file_path=&#39;jena/control-flow-statements-domain-schema.rdf&#39;):
    &#34;&#34;&#34;Save ontology data (static definitions only) as RDF file&#34;&#34;&#34;
    global WRITE_INVOLVES_CONCEPT
    global WRITE_PRINCIPAL_VIOLATION
    global WRITE_CONCEPT_FLAG_LABEL
    WRITE_INVOLVES_CONCEPT = True
    WRITE_PRINCIPAL_VIOLATION = True
    WRITE_CONCEPT_FLAG_LABEL = True
    create_ontology_tbox().save(file_path)

    print(&#34;Saved as:\t&#34;, file_path)</code></pre>
</details>
</dd>
<dt id="ctrlstrct_run.uniqualize_iri"><code class="name flex">
<span>def <span class="ident">uniqualize_iri</span></span>(<span>onto, iri)</span>
</code></dt>
<dd>
<div class="desc"><p>uniqualize individual's name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def uniqualize_iri(onto, iri):
    &#34;&#34;&#34;uniqualize individual&#39;s name&#34;&#34;&#34;
    n = 2
    orig_iri = iri
    while onto[iri]:  # while the name is in use
        # modify the name
        iri = orig_iri + (&#34;_%d&#34; % n)
        n += 1
    return iri</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ctrlstrct_run.TraceTester"><code class="flex name class">
<span>class <span class="ident">TraceTester</span></span>
<span>(</span><span>trace_data)</span>
</code></dt>
<dd>
<div class="desc"><p>manage preparation of algorithm &amp; trace data injection into ontology
(before reasoning run)</p>
<p>trace_data: dict like
{
"trace_name"
: str,
"algorithm_name": str,
"trace"
: list,
"algorithm"
: dict,
"header_boolean_chain" : list of bool - chain of conditions results
}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TraceTester():
    &#34;&#34;&#34; manage preparation of algorithm &amp; trace data injection into ontology
    (before reasoning run)
    &#34;&#34;&#34;

    def __init__(self, trace_data):
        &#34;&#34;&#34;trace_data: dict like
         {
            &#34;trace_name&#34;    : str,
            &#34;algorithm_name&#34;: str,
            &#34;trace&#34;         : list,
            &#34;algorithm&#34;     : dict,
            &#34;header_boolean_chain&#34; : list of bool - chain of conditions results
         }
        &#34;&#34;&#34;
        self.data = trace_data

        # index of all objects of the ALGORITHM for quick search by id
        self.id2obj = self.data[&#34;algorithm&#34;].get(&#34;id2obj&#34;, {})

        self.initial_repair_data()

        self.act_iris = []

        self._maxID = 1

    def initial_repair_data(self):
        &#34;&#34;&#34;patch data if it is not connected properly but is replicated instead (ex. after JSON serialization)&#34;&#34;&#34;

        # repair dicts&#39; &#34;id&#34; values that are str, not int
        k = &#39;id&#39;
        for d in find_by_key_in(k, self.data):
            if isinstance(d[k], str):
                d[k] = int(d[k])
        # repair dicts keys that are str, not int
        for k in list(self.id2obj.keys()):
            if isinstance(k, str):
                self.id2obj[int(k)] = self.id2obj[k]
                del self.id2obj[k]

        data = self.data[&#34;algorithm&#34;]  # data to repair

        if &#34;functions&#34; not in data:
            data[&#34;functions&#34;] = ()

        roots = data[&#34;global_code&#34;], data[&#34;functions&#34;]  # where actual data to be stored

        k = &#39;id&#39;
        for d in find_by_keyval_in(k, data[&#34;entry_point&#34;][k], roots):
            data[&#34;entry_point&#34;] = d  # reassign the appropriate node from roots (global_code or main function)
            break

        for ID in list(self.id2obj.keys()):
            for d in find_by_keyval_in(k, ID, roots):
                self.id2obj[ID] = d  # reassign the appropriate node from roots
                break

    def newID(self, what=None):
        &#34;&#34;&#34;Increment and return new unused integer ID&#34;&#34;&#34;
        while True:
            self._maxID += 1
            if self._maxID not in self.id2obj:
                break
        return self._maxID

    def alg_entry(self):
        &#34;&#34;&#34;Get entry point of algorithm&#34;&#34;&#34;
        if &#34;entry_point&#34; in self.data[&#34;algorithm&#34;]:
            alg_node = self.data[&#34;algorithm&#34;][&#34;entry_point&#34;]
        else:
            raise &#34;Cannot resolve &#39;entry_point&#39; from algorithm&#39;s keys: &#34; + str(list(self.data[&#34;algorithm&#34;].keys()))
        return alg_node

    def make_correct_trace(self, noop=False):
        &#34;&#34;&#34;Fill `self.data[&#34;correct_trace&#34;]` with correct sequence of acts
        taking care of control-condition values.
        This repeats ordinary logic of each control-structure in the algorithm.&#34;&#34;&#34;

        self.data[&#34;correct_trace&#34;] = []
        self.expr_id2values = {}

        if noop:
            return  # !!!

        def _gen(states_str):
            for ch in states_str:
                yield bool(int(ch))
            while 1:
                yield None

        self.last_cond_tuple = (-1, False)
        self.consequent_mode = &#34;normal&#34;  # other values: &#34;return&#34;, &#34;break&#34;, &#34;continue&#34;

        self._maxID = max(self._maxID, max(map(int, self.id2obj.keys())) + 10)

        # decide where to read expr values from
        self.values_source = None
        if self.data[&#34;header_boolean_chain&#34;]:
            # source №1: the boolean chain attached to the trace
            self.values_source = &#34;boolean_chain&#34;
            self.condition_value_generator = _gen(self.data[&#34;header_boolean_chain&#34;])
        elif self.data[&#34;algorithm&#34;][&#34;expr_values&#34;]:
            # source №2: the values defined beside algorithm lines (this is used for 1-1 case when no boolean chain specified)
            self.values_source = &#34;algorithm&#34;
        else:
            # source №3: the values defined beside trace lines
            #  (this is less preferred as the trace may contain errors)
            self.values_source = &#34;trace&#34;


        def next_cond_value(expr_name=None, executes_id=None, n=None, default=False):

            i, _ = self.last_cond_tuple
            v = None

            if self.values_source == &#34;boolean_chain&#34;:
                v = next(self.condition_value_generator)
            else:
                assert n is not None, str(n)

                if self.values_source == &#34;algorithm&#34;:
                    assert expr_name is not None, str(expr_name)
                    expr_values_dict = self.data[&#34;algorithm&#34;][&#34;expr_values&#34;]
                    if expr_name in expr_values_dict:
                        expr_values = expr_values_dict[expr_name]
                    else:
                        raise ValueError(
                            f&#34;Algorithm processing error: No values of condition expression &#39;{expr_name}&#39; are provided.\nConsider example of how to specify values [true, true, false] for this condition as if it belongs to a loop:\n &lt;pre&gt;while {expr_name} -&gt; 110  // loop_name&lt;/pre&gt;&#34;)
                    v = get_ith_expr_value(expr_values, i=n - 1)

                if self.values_source == &#34;trace&#34;:
                    # find act with appropriate name and exec_time
                    # (phase is defaulted to &#34;finished&#34; as values are attached to these only)
                    assert expr_name is not None or executes_id is not None, str((expr_name, executes_id))
                    acts = [
                        act for act in
                        find_by_keyval_in(&#34;n&#34;, str(n), self.data[&#34;trace&#34;])
                        # act[&#34;n&#34;] == n and
                        if act[&#34;phase&#34;] in (&#34;finished&#34;, &#39;performed&#39;)
                            and (act[&#34;executes&#34;] == executes_id)
                    ]
                    if acts:
                        assert len(acts) == 1, &#34;Expected 1 act to be found, but got:\n &#34; + str(acts)
                        act = acts[0]
                        v = act.get(&#34;value&#34;, None)
                    else:
                        print(&#34;Warning: cannot find student_act: %s&#34; % (
                            dict(expr_name=expr_name, executes_id=executes_id, n=n)))

            if v is None:
                v = default
                print(&#34;next_cond_value(): defaulting to&#34;, default)
            self.last_cond_tuple = (i + 1, v)
            return v

        # long recursive function
        def make_correct_trace_for_alg_node(node):
            # copy reference
            result = self.data[&#34;correct_trace&#34;]

            if node[&#34;type&#34;] in {&#34;func&#34;}:

                phase = &#34;started&#34;
                ith = 1 + len([x for x in find_by_keyval_in(&#34;name&#34;, node[&#34;name&#34;], result) if x[&#34;phase&#34;] == phase])
                result.append({
                    &#34;id&#34;: self.newID(),
                    &#34;name&#34;: node[&#34;name&#34;],
                    &#34;executes&#34;: node[&#34;body&#34;][&#34;id&#34;],
                    &#34;phase&#34;: phase,
                    &#34;n&#34;: ith,
                    # &#34;text_line&#34;: None,
                    # &#34;comment&#34;: None,
                })

                for body_node in node[&#34;body&#34;][&#34;body&#34;]:
                    make_correct_trace_for_alg_node(body_node)

                if self.consequent_mode != &#34;normal&#34;:
                    # return encountered
                    self.consequent_mode = &#34;normal&#34;

                phase = &#34;finished&#34;
                ith = 1 + len([x for x in find_by_keyval_in(&#34;name&#34;, node[&#34;name&#34;], result) if x[&#34;phase&#34;] == phase])
                result.append({
                    &#34;id&#34;: self.newID(),
                    &#34;name&#34;: node[&#34;name&#34;],
                    &#34;executes&#34;: node[&#34;body&#34;][&#34;id&#34;],
                    &#34;phase&#34;: phase,
                    &#34;n&#34;: ith,
                    # &#34;text_line&#34;: None,
                    # &#34;comment&#34;: None,
                })

            if node[&#34;type&#34;] in {&#34;sequence&#34;, &#34;else&#34;}:

                # do not wrap &#39;global_code&#39;
                if node[&#34;name&#34;] != &#39;global_code&#39;:
                    phase = &#34;started&#34;
                    ith = 1 + len([x for x in find_by_keyval_in(&#34;name&#34;, node[&#34;name&#34;], result) if x[&#34;phase&#34;] == phase])
                    result.append({
                        &#34;id&#34;: self.newID(),
                        &#34;name&#34;: node[&#34;name&#34;],
                        &#34;executes&#34;: node[&#34;id&#34;],
                        &#34;phase&#34;: phase,
                        &#34;n&#34;: ith,
                        # &#34;text_line&#34;: None,
                        # &#34;comment&#34;: None,
                    })

                for body_node in node[&#34;body&#34;]:
                    make_correct_trace_for_alg_node(body_node)
                    if self.consequent_mode != &#34;normal&#34;:
                        break

                # do not wrap &#39;global_code&#39;
                if node[&#34;name&#34;] != &#39;global_code&#39;:
                    phase = &#34;finished&#34;
                    ith = 1 + len([x for x in find_by_keyval_in(&#34;name&#34;, node[&#34;name&#34;], result) if x[&#34;phase&#34;] == phase])
                    result.append({
                        &#34;id&#34;: self.newID(),
                        &#34;name&#34;: node[&#34;name&#34;],
                        &#34;executes&#34;: node[&#34;id&#34;],
                        &#34;phase&#34;: phase,
                        &#34;n&#34;: ith,
                        # &#34;text_line&#34;: None,
                        # &#34;comment&#34;: None,
                    })

            if node[&#34;type&#34;] in {&#34;alternative&#34;}:

                phase = &#34;started&#34;
                ith = 1 + len([x for x in find_by_keyval_in(&#34;name&#34;, node[&#34;name&#34;], result) if x[&#34;phase&#34;] == phase])
                result.append({
                    &#34;id&#34;: self.newID(),
                    &#34;name&#34;: node[&#34;name&#34;],
                    &#34;executes&#34;: node[&#34;id&#34;],
                    &#34;phase&#34;: phase,
                    &#34;n&#34;: ith,
                    # &#34;text_line&#34;: None,
                    # &#34;comment&#34;: None,
                })

                for branch in node[&#34;branches&#34;]:
                    make_correct_trace_for_alg_node(branch)
                    if self.last_cond_tuple[1] == True:
                        break
                    if self.consequent_mode != &#34;normal&#34;:
                        break

                phase = &#34;finished&#34;
                ith = 1 + len([x for x in find_by_keyval_in(&#34;name&#34;, node[&#34;name&#34;], result) if x[&#34;phase&#34;] == phase])
                result.append({
                    &#34;id&#34;: self.newID(),
                    &#34;name&#34;: node[&#34;name&#34;],
                    &#34;executes&#34;: node[&#34;id&#34;],
                    &#34;phase&#34;: phase,
                    &#34;n&#34;: ith,
                    # &#34;text_line&#34;: None,
                    # &#34;comment&#34;: None,
                })

            if node[&#34;type&#34;] in {&#34;if&#34;, &#34;else-if&#34;}:
                make_correct_trace_for_alg_node(node[&#34;cond&#34;])
                _, cond_v = self.last_cond_tuple
                if cond_v:
                    phase = &#34;started&#34;
                    ith = 1 + len([x for x in find_by_keyval_in(&#34;name&#34;, node[&#34;name&#34;], result) if x[&#34;phase&#34;] == phase])
                    result.append({
                        &#34;id&#34;: self.newID(),
                        &#34;name&#34;: node[&#34;name&#34;],
                        &#34;executes&#34;: node[&#34;id&#34;],
                        &#34;phase&#34;: phase,
                        &#34;n&#34;: ith,
                        # &#34;text_line&#34;: None,
                        # &#34;comment&#34;: None,
                    })

                    for body_node in node[&#34;body&#34;]:
                        make_correct_trace_for_alg_node(body_node)
                        if self.consequent_mode != &#34;normal&#34;:
                            break

                    phase = &#34;finished&#34;
                    ith = 1 + len([x for x in find_by_keyval_in(&#34;name&#34;, node[&#34;name&#34;], result) if x[&#34;phase&#34;] == phase])
                    result.append({
                        &#34;id&#34;: self.newID(),
                        &#34;name&#34;: node[&#34;name&#34;],
                        &#34;executes&#34;: node[&#34;id&#34;],
                        &#34;phase&#34;: phase,
                        &#34;n&#34;: ith,
                        # &#34;text_line&#34;: None,
                        # &#34;comment&#34;: None,
                    })

            if node[&#34;type&#34;] in {&#34;expr&#34;}:
                phase = &#34;performed&#34;
                ith = 1 + len([x for x in find_by_keyval_in(&#34;name&#34;, node[&#34;name&#34;], result) if x[&#34;phase&#34;] == phase])
                value = next_cond_value(node[&#34;name&#34;], node[&#34;id&#34;], ith)
                self.expr_id2values[node[&#34;id&#34;]] = self.expr_id2values.get(node[&#34;id&#34;], []) + [value]
                result.append({
                    &#34;id&#34;: self.newID(),
                    &#34;name&#34;: node[&#34;name&#34;],
                    &#34;value&#34;: value,
                    &#34;executes&#34;: node[&#34;id&#34;],
                    &#34;phase&#34;: phase,
                    &#34;n&#34;: ith,
                    # &#34;text_line&#34;: None,
                    # &#34;comment&#34;: None,
                })

            if node[&#34;type&#34;] in {&#34;stmt&#34;, &#34;break&#34;, &#34;continue&#34;, &#34;return&#34;}:
                phase = &#34;performed&#34;
                ith = 1 + len([x for x in find_by_keyval_in(&#34;name&#34;, node[&#34;name&#34;], result) if x[&#34;phase&#34;] == phase])
                result.append({
                    &#34;id&#34;: self.newID(),
                    &#34;name&#34;: node[&#34;name&#34;],
                    &#34;executes&#34;: node[&#34;id&#34;],
                    &#34;phase&#34;: phase,
                    &#34;n&#34;: ith,
                    # &#34;text_line&#34;: None,
                    # &#34;comment&#34;: None,
                })
                if node[&#34;type&#34;] in {&#34;break&#34;, &#34;continue&#34;, &#34;return&#34;}:
                    self.consequent_mode = node[&#34;type&#34;]
                    return  # just stupidly stop current sequence

            # TODO: keep list of loop classes up-to-date
            if node[&#34;type&#34;] in {&#34;while_loop&#34;, &#34;do_while_loop&#34;, &#34;do_until_loop&#34;, &#34;for_loop&#34;, &#34;foreach_loop&#34;,
                                &#34;infinite_loop&#34;, }:

                phase = &#34;started&#34;
                ith = 1 + len([x for x in find_by_keyval_in(&#34;name&#34;, node[&#34;name&#34;], result) if x[&#34;phase&#34;] == phase])
                result.append({
                    &#34;id&#34;: self.newID(),
                    &#34;name&#34;: node[&#34;name&#34;],
                    &#34;executes&#34;: node[&#34;id&#34;],
                    &#34;phase&#34;: phase,
                    &#34;n&#34;: ith,
                    # &#34;text_line&#34;: None,
                    # &#34;comment&#34;: None,
                })

                inverse_cond = node[&#34;type&#34;] == &#34;do_until_loop&#34;
                stop_cond_value = True == inverse_cond

                def _loop_context():  # wrapper for return
                    # loop begin
                    if node[&#34;type&#34;] in {&#34;for_loop&#34;, &#34;foreach_loop&#34;}:
                        make_correct_trace_for_alg_node(node[&#34;init&#34;])

                    if node[&#34;type&#34;] in {&#34;while_loop&#34;, &#34;for_loop&#34;, &#34;foreach_loop&#34;}:
                        make_correct_trace_for_alg_node(node[&#34;cond&#34;])
                        if self.last_cond_tuple[1] == stop_cond_value:
                            return

                    # loop cycle
                    while (True):

                        if node[&#34;type&#34;] in {&#34;foreach_loop&#34;}:
                            make_correct_trace_for_alg_node(node[&#34;update&#34;])

                        # a loop iteration!
                        make_correct_trace_for_alg_node(node[&#34;body&#34;])

                        if self.consequent_mode == &#34;continue&#34;:
                            # reset mode
                            self.consequent_mode = &#34;normal&#34;
                        elif self.consequent_mode == &#34;break&#34;:
                            # reset mode
                            self.consequent_mode = &#34;normal&#34;
                            return
                        elif self.consequent_mode != &#34;normal&#34;:
                            # return encountered
                            return

                        if node[&#34;type&#34;] in {&#34;for_loop&#34;}:
                            make_correct_trace_for_alg_node(node[&#34;update&#34;])

                        if node[&#34;type&#34;] not in {&#34;infinite_loop&#34;}:
                            make_correct_trace_for_alg_node(node[&#34;cond&#34;])
                            if self.last_cond_tuple[1] == stop_cond_value:
                                return

                _loop_context()  # make a loop

                phase = &#34;finished&#34;
                ith = 1 + len([x for x in find_by_keyval_in(&#34;name&#34;, node[&#34;name&#34;], result) if x[&#34;phase&#34;] == phase])
                result.append({
                    &#34;id&#34;: self.newID(),
                    &#34;name&#34;: node[&#34;name&#34;],
                    &#34;executes&#34;: node[&#34;id&#34;],
                    &#34;phase&#34;: phase,
                    &#34;n&#34;: ith,
                    # &#34;text_line&#34;: None,
                    # &#34;comment&#34;: None,
                })

        alg_node = self.alg_entry()

        name = &#34;program&#34;
        phase = &#34;started&#34;
        self.data[&#34;correct_trace&#34;].append({
            &#34;id&#34;: self.newID(),
            &#34;name&#34;: name,
            &#34;executes&#34;: alg_node[&#34;id&#34;],
            &#34;phase&#34;: phase,
            &#34;n&#34;: 1,
            # &#34;text_line&#34;: None,
            # &#34;comment&#34;: None,
        })
        make_correct_trace_for_alg_node(alg_node)
        phase = &#34;finished&#34;
        self.data[&#34;correct_trace&#34;].append({
            &#34;id&#34;: self.newID(),
            &#34;name&#34;: name,
            &#34;executes&#34;: alg_node[&#34;id&#34;],
            &#34;phase&#34;: phase,
            &#34;n&#34;: 1,
            # &#34;text_line&#34;: None,
            # &#34;comment&#34;: None,
        })


    def inject_to_ontology(self, onto):

        self.inject_algorithm_to_ontology(onto)

        self.make_correct_trace(noop=True)
        self.prepare_act_candidates(onto)
        self.inject_trace_to_ontology(onto, self.data[&#34;trace&#34;], (), &#34;student_next&#34;)


    def prepare_id2obj(self):
        &#34;&#34;&#34;Fill `self.id2obj` with direct references to algorithm objects &#34;&#34;&#34;
        alg_objects = list(find_by_type(self.data[&#34;algorithm&#34;]))
        if not self.id2obj:
            # fill it once
            for d in alg_objects:
                if &#34;id&#34; in d:
                    self.id2obj[d[&#34;id&#34;]] = d
            # store to original algorithm dict
            self.data[&#34;algorithm&#34;][&#34;id2obj&#34;] = self.id2obj


    def inject_algorithm_to_ontology(self, onto):
        &#34;&#34;&#34;Prepares self.id2obj and writes algorithm to ontology if it isn&#39;t there.&#34;&#34;&#34;

        if &#34;entry_point&#34; not in self.data[&#34;algorithm&#34;]:
            alg_node = self.data[&#34;algorithm&#34;][&#34;global_code&#34;]
            # polyfill entry_point to be global_code
            self.data[&#34;algorithm&#34;][&#34;entry_point&#34;] = alg_node

        self.prepare_id2obj()

        with onto:
            if onto.algorithm_name and self.data[&#34;algorithm_name&#34;] in [s for _, s in
                                                                       onto.algorithm_name.get_relations()]:
                # do nothing as the algorithm is in the ontology
                return

            alg_objects = list(find_by_type(self.data[&#34;algorithm&#34;]))

            written_ids = set()

            # make algorithm classes and individuals
            for d in alg_objects:
                if &#34;id&#34; not in d:
                    continue
                id_ = d.get(&#34;id&#34;)

                # (once more) protection from objects cloned via JSON serialization
                if id_ in written_ids:
                    continue
                else:
                    written_ids.add(id_)

                type_ = d.get(&#34;type&#34;)
                name = d.get(&#34;name&#34;, None) or d.get(&#34;stmt_name&#34;, &#34;&#34;)

                assert type_, &#34;Error: No &#39;type&#39; in algorithm object: &#34; + str(d)

                id_ = int(id_)
                clean_name = prepare_name(name)

                class_ = onto[type_]
                if not class_:
                    # make a new class in the ontology
                    class_ = types.new_class(type_, (Thing,))

                # make the name of individual (instance) in the ontology
                iri = &#34;{}_{}&#34;.format(id_, clean_name)

                iri = uniqualize_iri(onto, iri)

                # save back to our dict (to bind to acts later)
                d[&#34;iri&#34;] = iri
                # make an instance
                obj = class_(iri)
                # bind id
                make_triple(obj, onto.id, id_)
                # bind name
                make_triple(obj, onto.stmt_name, name)

                # make special string link identifying algorithm
                if type_ == &#34;algorithm&#34;:
                    prop = onto[&#34;algorithm_name&#34;]
                    if not prop:
                        with onto:
                            # new named relation
                            prop = types.new_class(&#34;algorithm_name&#34;, (Thing &gt;&gt; str,))
                    make_triple(obj, prop, self.data[&#34;algorithm_name&#34;])
                else:
                    # connect begin &amp; end
                    class_ = onto.boundary
                    for prop_name in (&#34;begin_of&#34;, &#34;end_of&#34;):
                        bound = class_(prop_name + &#34;_&#34; + iri)
                        make_triple(bound, onto[prop_name], obj)

            # link the instances: repeat the structure completely
            for d in alg_objects:
                if &#34;id&#34; not in d:
                    continue
                for k in d:  # look through dict keys
                    v = d[k]
                    if isinstance(v, dict) and &#34;id&#34; in v and &#34;iri&#34; in v:
                        # connect all the properties of the instance
                        link_objects(onto, d[&#34;iri&#34;], k, v[&#34;iri&#34;], (Thing &gt;&gt; Thing, onto.parent_of,))
                    elif isinstance(v, (list, set)):
                        # make an ordered linked_list for list, unordered for set
                        # make a list if it contains normal &#34;our&#34; objects
                        subobject_iri_list = [subv[&#34;iri&#34;] for subv in v if
                                              isinstance(subv, dict) and &#34;id&#34; in subv and &#34;iri&#34; in subv]
                        if not subobject_iri_list:
                            continue

                        iri = d[&#34;iri&#34;]

                        # Any list (actions, branches, ...) must be formatted as linked_list.
                        if k == &#34;body&#34; and isinstance(v, list):
                            # make the object a sequence (needed for loop bodies, branches, functions)
                            onto[iri].is_a.append(onto.linked_list)

                        subelem__prop_name = k + &#34;_item&#34;
                        for i, subiri in enumerate(subobject_iri_list):
                            # main relation
                            link_objects(onto, iri, subelem__prop_name, subiri, (Thing &gt;&gt; Thing, onto.parent_of,))
                            if isinstance(v, list):  # for list only
                                # sequence
                                if i &gt;= 1:
                                    prev_iri = subobject_iri_list[i - 1]
                                    link_objects(onto, prev_iri, &#34;next&#34;, subiri)
                                # set the index of elem in the list
                                onto[subiri].item_index = i
                                # first / last
                                if i == 0:
                                    # mark as first elem of the list
                                    onto[subiri].is_a.append(onto.first_item)
                                if i == len(subobject_iri_list) - 1:
                                    # mark as last act of the list
                                    onto[subiri].is_a.append(onto.last_item)

    def prepare_act_candidates(self, onto):
        &#34;&#34;&#34;Create all required acts for each statement. &#34;&#34;&#34;

        alg_id2max_exec_n = {st_id: 0 for st_id in self.id2obj.keys()}  # executed stmt id to max exec_time of the act
        for act in self.data[&#34;correct_trace&#34;]:
            executed_id = act[&#34;executes&#34;]
            exec_n = act[&#34;n&#34;]
            alg_id2max_exec_n[executed_id] = exec_n  # assume &#34;n&#34;s appear consequently in the trace

        # ensure that student&#39;s acts exist
        for act in self.data[&#34;trace&#34;]:
            executed_id = act[&#34;executes&#34;]
            exec_n = act.get(&#34;n&#34;, &#34;1&#34;)
            alg_id2max_exec_n[executed_id] = max(
                int(exec_n),  # assume &#34;n&#34;s appear consequently in the trace
                int(alg_id2max_exec_n[executed_id]))

        entry_stmt_id = self.alg_entry()[&#34;id&#34;]

        max_act_ID = 1000

        def set_id(act_obj):
            nonlocal max_act_ID
            max_act_ID += 1
            make_triple(act_obj, onto.id, max_act_ID)

        # make top-level act representing the trace ...
        iri = f&#39;trace_{self.data[&#34;trace_name&#34;]}&#39;
        if self.data[&#34;header_boolean_chain&#34;]:
            iri += f&#39;_c{&#34;&#34;.join(map(str, map(int, self.data[&#34;header_boolean_chain&#34;])))}&#39;

        iri = iri.replace(&#34; &#34;, &#34;_&#34;).strip(&#34;_&#34;)

        iri = prepare_name(iri)
        iri = uniqualize_iri(onto, iri)
        trace_obj = onto.trace(iri)
        self.trace_obj = trace_obj  # remember for trace injection
        trace_obj.is_a.append(onto.correct_act)
        make_triple(trace_obj, onto.executes, onto[self.data[&#34;algorithm&#34;][&#34;iri&#34;]])
        set_id(trace_obj)
        make_triple(trace_obj, onto.index, 0)
        make_triple(trace_obj, onto.student_index, 0)
        make_triple(trace_obj, onto.exec_time, 0)  # set to 0 so next is 1
        make_triple(trace_obj, onto.depth, 0)  # set to 0 so next is 1
        make_triple(trace_obj, onto.in_trace, trace_obj)  # each act belongs to trace

        for st_id, max_n in alg_id2max_exec_n.items():

            alg_elem = self.id2obj[st_id]
            if alg_elem[&#34;type&#34;] in {&#34;algorithm&#34;}:
                continue

            # prepare data
            name = alg_elem.get(&#34;name&#34;, &#34;unkn&#34;)
            clean_name = prepare_name(name)

            mark2act_obj = {}  # executed stmt id to list of act iri&#39;s can be consequently used in trace

            for exec_n in range(1, max_n + 1):

                # make instances: act_begin, act_end
                number_mark = &#34;&#34; if max_n &lt;= 1 else (&#34;_n%02d&#34; % exec_n)
                iri_template = f&#34;%s_{clean_name}{number_mark}&#34;  # _i{index:02}

                for mark, class_, boundary_prop in [(&#34;b&#34;, onto.act_begin, onto.begin_of),
                                                    (&#34;e&#34;, onto.act_end, onto.end_of)]:
                    iri = iri_template % mark
                    iri = uniqualize_iri(onto, iri)

                    obj = class_(iri)

                    boundary = get_relation_subject(boundary_prop, onto[alg_elem[&#34;iri&#34;]])
                    make_triple(obj, onto.executes, boundary)

                    set_id(obj)
                    make_triple(obj, onto.exec_time, exec_n)
                    make_triple(obj, onto.in_trace, trace_obj)

                    # keep current value for next iteration
                    mark2act_obj[mark] = obj

                    # attach expr value: for act_end only!
                    if mark == &#34;e&#34; and alg_elem[&#34;type&#34;] in (&#34;expr&#34;,):
                        values = self.expr_id2values[st_id] if st_id in self.expr_id2values else []
                        # if len(values) &lt;= exec_n:
                        if exec_n &lt;= len(values):
                            value = values[exec_n - 1]
                        else:
                            value = False
                            print(&#34;attach expr value: defaulting to False...&#34;)
                        make_triple(obj, onto.expr_value, value)


    def inject_trace_to_ontology(self, onto, trace, act_classnames=(&#34;act&#34;,), next_propertyname=None):
        &#34;Writes specified trace to ontology assigning properties to pre-created acts.&#34;

        additional_classes = [onto[nm] for nm in act_classnames]
        assert all(additional_classes), f&#34;additional_classes={additional_classes}, {act_classnames}, {onto}&#34;

        # make trace acts as individuals

        prop_class = onto[next_propertyname]

        def connect_next_act(obj):
            trace_acts_list.append(obj)
            # generate a consecutive list
            if prop_class and len(trace_acts_list) &gt; 1:
                # bind next, if specified
                prev_obj = trace_acts_list[-2]
                obj = trace_acts_list[-1]
                make_triple(prev_obj, prop_class, obj)
            if trace_acts_list:
                num = len(trace_acts_list)
                make_triple(obj, onto.student_index, num)

        def find_act(class_, executes: int, exec_time: int, **fields: dict):
            for obj in class_.instances():
                if ((
                        # an act executes a boundary while trace executes algorithm itself
                        obj.executes.INDIRECT_boundary_of or obj.executes
                ).id == executes and
                        ((obj.exec_time == exec_time) or (exec_time is None)) and
                        (self.trace_obj in obj.in_trace) and
                        all((getattr(obj, k, None) == v) or (v is None) for k, v in fields.items())):
                    return obj
            print(
                f&#34;act not found: ex={executes}, {&#39;, &#39;.join([f&#39;n={exec_time}&#39;] + [f&#39;{k}={v}&#39; for k, v in fields.items()])}&#34;)
            return None

        with onto:
            i = 0
            trace_acts_list = []
            trace_acts_list.append(find_act(onto.trace, self.data[&#34;algorithm&#34;][&#34;id&#34;], 0))
            for d in trace:
                i += 1
                if &#34;id&#34; in d:
                    id_ = d.get(&#34;id&#34;)
                    executes = d.get(&#34;executes&#34;)
                    # phase: (started|finished|performed)
                    phase = d.get(&#34;phase&#34;)  # , &#34;performed&#34;
                    n = d.get(&#34;n&#34;, None) or d.get(&#34;n_&#34;, None)
                    iteration_n = d.get(&#34;iteration_n&#34;, None)
                    name = d.get(&#34;name&#34;, None) or d.get(&#34;action&#34;, None)  # !  name &lt;- action
                    text_line = d.get(&#34;text_line&#34;, None)
                    expr_value = d.get(&#34;value&#34;, None)

                    id_ = int(id_)
                    # clean_name = prepare_name(name)
                    phase_mark = {&#34;started&#34;: &#34;b&#34;, &#34;finished&#34;: &#34;e&#34;, &#34;performed&#34;: &#34;p&#34;, }[phase]
                    n = n and int(n)  # convert if not None (n cannot be 0)
                    # number_mark = &#34;&#34; if not n else (&#34;_n%d&#34; % n)

                    # find related algorithm element
                    assert executes in self.id2obj, (self.id2obj, d)
                    alg_elem = self.id2obj[executes]

                    if phase_mark in (&#34;b&#34;, &#34;p&#34;):
                        # act begin
                        obj = find_act(onto.act_begin, executes, n or None)
                        if obj:
                            for class_ in additional_classes:
                                obj.is_a.append(class_)
                            # bind the required properties
                            make_triple(obj, onto.text_line, text_line)
                            make_triple(obj, onto.id,
                                        id_)  # IDs may be non-unique, but must match the id of the acts from the GUI
                            if iteration_n:
                                make_triple(obj, onto.student_iteration_n, iteration_n)

                            connect_next_act(obj)
                        else:
                            print(&#34;  act name:&#34;, name)

                    if phase_mark in (&#34;e&#34;, &#34;p&#34;):
                        # конец акта
                        obj = find_act(onto.act_end, executes, n or None)
                        if obj:
                            for class_ in additional_classes:
                                obj.is_a.append(class_)
                            # bind the required properties
                            make_triple(obj, onto.text_line, text_line)
                            make_triple(obj, onto.id,
                                        id_)  # IDs may be non-unique, but must match the id of the acts from the GUI
                            if expr_value is not None:
                                make_triple(obj, onto.expr_value, expr_value)
                            if iteration_n:
                                make_triple(obj, onto.student_iteration_n, iteration_n)

                            connect_next_act(obj)
                        else:
                            print(&#34;  act name:&#34;, name)

    # end of TraceTester class</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ctrlstrct_run.TraceTester.alg_entry"><code class="name flex">
<span>def <span class="ident">alg_entry</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get entry point of algorithm</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def alg_entry(self):
    &#34;&#34;&#34;Get entry point of algorithm&#34;&#34;&#34;
    if &#34;entry_point&#34; in self.data[&#34;algorithm&#34;]:
        alg_node = self.data[&#34;algorithm&#34;][&#34;entry_point&#34;]
    else:
        raise &#34;Cannot resolve &#39;entry_point&#39; from algorithm&#39;s keys: &#34; + str(list(self.data[&#34;algorithm&#34;].keys()))
    return alg_node</code></pre>
</details>
</dd>
<dt id="ctrlstrct_run.TraceTester.initial_repair_data"><code class="name flex">
<span>def <span class="ident">initial_repair_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>patch data if it is not connected properly but is replicated instead (ex. after JSON serialization)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initial_repair_data(self):
    &#34;&#34;&#34;patch data if it is not connected properly but is replicated instead (ex. after JSON serialization)&#34;&#34;&#34;

    # repair dicts&#39; &#34;id&#34; values that are str, not int
    k = &#39;id&#39;
    for d in find_by_key_in(k, self.data):
        if isinstance(d[k], str):
            d[k] = int(d[k])
    # repair dicts keys that are str, not int
    for k in list(self.id2obj.keys()):
        if isinstance(k, str):
            self.id2obj[int(k)] = self.id2obj[k]
            del self.id2obj[k]

    data = self.data[&#34;algorithm&#34;]  # data to repair

    if &#34;functions&#34; not in data:
        data[&#34;functions&#34;] = ()

    roots = data[&#34;global_code&#34;], data[&#34;functions&#34;]  # where actual data to be stored

    k = &#39;id&#39;
    for d in find_by_keyval_in(k, data[&#34;entry_point&#34;][k], roots):
        data[&#34;entry_point&#34;] = d  # reassign the appropriate node from roots (global_code or main function)
        break

    for ID in list(self.id2obj.keys()):
        for d in find_by_keyval_in(k, ID, roots):
            self.id2obj[ID] = d  # reassign the appropriate node from roots
            break</code></pre>
</details>
</dd>
<dt id="ctrlstrct_run.TraceTester.inject_algorithm_to_ontology"><code class="name flex">
<span>def <span class="ident">inject_algorithm_to_ontology</span></span>(<span>self, onto)</span>
</code></dt>
<dd>
<div class="desc"><p>Prepares self.id2obj and writes algorithm to ontology if it isn't there.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inject_algorithm_to_ontology(self, onto):
    &#34;&#34;&#34;Prepares self.id2obj and writes algorithm to ontology if it isn&#39;t there.&#34;&#34;&#34;

    if &#34;entry_point&#34; not in self.data[&#34;algorithm&#34;]:
        alg_node = self.data[&#34;algorithm&#34;][&#34;global_code&#34;]
        # polyfill entry_point to be global_code
        self.data[&#34;algorithm&#34;][&#34;entry_point&#34;] = alg_node

    self.prepare_id2obj()

    with onto:
        if onto.algorithm_name and self.data[&#34;algorithm_name&#34;] in [s for _, s in
                                                                   onto.algorithm_name.get_relations()]:
            # do nothing as the algorithm is in the ontology
            return

        alg_objects = list(find_by_type(self.data[&#34;algorithm&#34;]))

        written_ids = set()

        # make algorithm classes and individuals
        for d in alg_objects:
            if &#34;id&#34; not in d:
                continue
            id_ = d.get(&#34;id&#34;)

            # (once more) protection from objects cloned via JSON serialization
            if id_ in written_ids:
                continue
            else:
                written_ids.add(id_)

            type_ = d.get(&#34;type&#34;)
            name = d.get(&#34;name&#34;, None) or d.get(&#34;stmt_name&#34;, &#34;&#34;)

            assert type_, &#34;Error: No &#39;type&#39; in algorithm object: &#34; + str(d)

            id_ = int(id_)
            clean_name = prepare_name(name)

            class_ = onto[type_]
            if not class_:
                # make a new class in the ontology
                class_ = types.new_class(type_, (Thing,))

            # make the name of individual (instance) in the ontology
            iri = &#34;{}_{}&#34;.format(id_, clean_name)

            iri = uniqualize_iri(onto, iri)

            # save back to our dict (to bind to acts later)
            d[&#34;iri&#34;] = iri
            # make an instance
            obj = class_(iri)
            # bind id
            make_triple(obj, onto.id, id_)
            # bind name
            make_triple(obj, onto.stmt_name, name)

            # make special string link identifying algorithm
            if type_ == &#34;algorithm&#34;:
                prop = onto[&#34;algorithm_name&#34;]
                if not prop:
                    with onto:
                        # new named relation
                        prop = types.new_class(&#34;algorithm_name&#34;, (Thing &gt;&gt; str,))
                make_triple(obj, prop, self.data[&#34;algorithm_name&#34;])
            else:
                # connect begin &amp; end
                class_ = onto.boundary
                for prop_name in (&#34;begin_of&#34;, &#34;end_of&#34;):
                    bound = class_(prop_name + &#34;_&#34; + iri)
                    make_triple(bound, onto[prop_name], obj)

        # link the instances: repeat the structure completely
        for d in alg_objects:
            if &#34;id&#34; not in d:
                continue
            for k in d:  # look through dict keys
                v = d[k]
                if isinstance(v, dict) and &#34;id&#34; in v and &#34;iri&#34; in v:
                    # connect all the properties of the instance
                    link_objects(onto, d[&#34;iri&#34;], k, v[&#34;iri&#34;], (Thing &gt;&gt; Thing, onto.parent_of,))
                elif isinstance(v, (list, set)):
                    # make an ordered linked_list for list, unordered for set
                    # make a list if it contains normal &#34;our&#34; objects
                    subobject_iri_list = [subv[&#34;iri&#34;] for subv in v if
                                          isinstance(subv, dict) and &#34;id&#34; in subv and &#34;iri&#34; in subv]
                    if not subobject_iri_list:
                        continue

                    iri = d[&#34;iri&#34;]

                    # Any list (actions, branches, ...) must be formatted as linked_list.
                    if k == &#34;body&#34; and isinstance(v, list):
                        # make the object a sequence (needed for loop bodies, branches, functions)
                        onto[iri].is_a.append(onto.linked_list)

                    subelem__prop_name = k + &#34;_item&#34;
                    for i, subiri in enumerate(subobject_iri_list):
                        # main relation
                        link_objects(onto, iri, subelem__prop_name, subiri, (Thing &gt;&gt; Thing, onto.parent_of,))
                        if isinstance(v, list):  # for list only
                            # sequence
                            if i &gt;= 1:
                                prev_iri = subobject_iri_list[i - 1]
                                link_objects(onto, prev_iri, &#34;next&#34;, subiri)
                            # set the index of elem in the list
                            onto[subiri].item_index = i
                            # first / last
                            if i == 0:
                                # mark as first elem of the list
                                onto[subiri].is_a.append(onto.first_item)
                            if i == len(subobject_iri_list) - 1:
                                # mark as last act of the list
                                onto[subiri].is_a.append(onto.last_item)</code></pre>
</details>
</dd>
<dt id="ctrlstrct_run.TraceTester.inject_to_ontology"><code class="name flex">
<span>def <span class="ident">inject_to_ontology</span></span>(<span>self, onto)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inject_to_ontology(self, onto):

    self.inject_algorithm_to_ontology(onto)

    self.make_correct_trace(noop=True)
    self.prepare_act_candidates(onto)
    self.inject_trace_to_ontology(onto, self.data[&#34;trace&#34;], (), &#34;student_next&#34;)</code></pre>
</details>
</dd>
<dt id="ctrlstrct_run.TraceTester.inject_trace_to_ontology"><code class="name flex">
<span>def <span class="ident">inject_trace_to_ontology</span></span>(<span>self, onto, trace, act_classnames=('act',), next_propertyname=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes specified trace to ontology assigning properties to pre-created acts.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inject_trace_to_ontology(self, onto, trace, act_classnames=(&#34;act&#34;,), next_propertyname=None):
    &#34;Writes specified trace to ontology assigning properties to pre-created acts.&#34;

    additional_classes = [onto[nm] for nm in act_classnames]
    assert all(additional_classes), f&#34;additional_classes={additional_classes}, {act_classnames}, {onto}&#34;

    # make trace acts as individuals

    prop_class = onto[next_propertyname]

    def connect_next_act(obj):
        trace_acts_list.append(obj)
        # generate a consecutive list
        if prop_class and len(trace_acts_list) &gt; 1:
            # bind next, if specified
            prev_obj = trace_acts_list[-2]
            obj = trace_acts_list[-1]
            make_triple(prev_obj, prop_class, obj)
        if trace_acts_list:
            num = len(trace_acts_list)
            make_triple(obj, onto.student_index, num)

    def find_act(class_, executes: int, exec_time: int, **fields: dict):
        for obj in class_.instances():
            if ((
                    # an act executes a boundary while trace executes algorithm itself
                    obj.executes.INDIRECT_boundary_of or obj.executes
            ).id == executes and
                    ((obj.exec_time == exec_time) or (exec_time is None)) and
                    (self.trace_obj in obj.in_trace) and
                    all((getattr(obj, k, None) == v) or (v is None) for k, v in fields.items())):
                return obj
        print(
            f&#34;act not found: ex={executes}, {&#39;, &#39;.join([f&#39;n={exec_time}&#39;] + [f&#39;{k}={v}&#39; for k, v in fields.items()])}&#34;)
        return None

    with onto:
        i = 0
        trace_acts_list = []
        trace_acts_list.append(find_act(onto.trace, self.data[&#34;algorithm&#34;][&#34;id&#34;], 0))
        for d in trace:
            i += 1
            if &#34;id&#34; in d:
                id_ = d.get(&#34;id&#34;)
                executes = d.get(&#34;executes&#34;)
                # phase: (started|finished|performed)
                phase = d.get(&#34;phase&#34;)  # , &#34;performed&#34;
                n = d.get(&#34;n&#34;, None) or d.get(&#34;n_&#34;, None)
                iteration_n = d.get(&#34;iteration_n&#34;, None)
                name = d.get(&#34;name&#34;, None) or d.get(&#34;action&#34;, None)  # !  name &lt;- action
                text_line = d.get(&#34;text_line&#34;, None)
                expr_value = d.get(&#34;value&#34;, None)

                id_ = int(id_)
                # clean_name = prepare_name(name)
                phase_mark = {&#34;started&#34;: &#34;b&#34;, &#34;finished&#34;: &#34;e&#34;, &#34;performed&#34;: &#34;p&#34;, }[phase]
                n = n and int(n)  # convert if not None (n cannot be 0)
                # number_mark = &#34;&#34; if not n else (&#34;_n%d&#34; % n)

                # find related algorithm element
                assert executes in self.id2obj, (self.id2obj, d)
                alg_elem = self.id2obj[executes]

                if phase_mark in (&#34;b&#34;, &#34;p&#34;):
                    # act begin
                    obj = find_act(onto.act_begin, executes, n or None)
                    if obj:
                        for class_ in additional_classes:
                            obj.is_a.append(class_)
                        # bind the required properties
                        make_triple(obj, onto.text_line, text_line)
                        make_triple(obj, onto.id,
                                    id_)  # IDs may be non-unique, but must match the id of the acts from the GUI
                        if iteration_n:
                            make_triple(obj, onto.student_iteration_n, iteration_n)

                        connect_next_act(obj)
                    else:
                        print(&#34;  act name:&#34;, name)

                if phase_mark in (&#34;e&#34;, &#34;p&#34;):
                    # конец акта
                    obj = find_act(onto.act_end, executes, n or None)
                    if obj:
                        for class_ in additional_classes:
                            obj.is_a.append(class_)
                        # bind the required properties
                        make_triple(obj, onto.text_line, text_line)
                        make_triple(obj, onto.id,
                                    id_)  # IDs may be non-unique, but must match the id of the acts from the GUI
                        if expr_value is not None:
                            make_triple(obj, onto.expr_value, expr_value)
                        if iteration_n:
                            make_triple(obj, onto.student_iteration_n, iteration_n)

                        connect_next_act(obj)
                    else:
                        print(&#34;  act name:&#34;, name)</code></pre>
</details>
</dd>
<dt id="ctrlstrct_run.TraceTester.make_correct_trace"><code class="name flex">
<span>def <span class="ident">make_correct_trace</span></span>(<span>self, noop=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Fill <code>self.data["correct_trace"]</code> with correct sequence of acts
taking care of control-condition values.
This repeats ordinary logic of each control-structure in the algorithm.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_correct_trace(self, noop=False):
    &#34;&#34;&#34;Fill `self.data[&#34;correct_trace&#34;]` with correct sequence of acts
    taking care of control-condition values.
    This repeats ordinary logic of each control-structure in the algorithm.&#34;&#34;&#34;

    self.data[&#34;correct_trace&#34;] = []
    self.expr_id2values = {}

    if noop:
        return  # !!!

    def _gen(states_str):
        for ch in states_str:
            yield bool(int(ch))
        while 1:
            yield None

    self.last_cond_tuple = (-1, False)
    self.consequent_mode = &#34;normal&#34;  # other values: &#34;return&#34;, &#34;break&#34;, &#34;continue&#34;

    self._maxID = max(self._maxID, max(map(int, self.id2obj.keys())) + 10)

    # decide where to read expr values from
    self.values_source = None
    if self.data[&#34;header_boolean_chain&#34;]:
        # source №1: the boolean chain attached to the trace
        self.values_source = &#34;boolean_chain&#34;
        self.condition_value_generator = _gen(self.data[&#34;header_boolean_chain&#34;])
    elif self.data[&#34;algorithm&#34;][&#34;expr_values&#34;]:
        # source №2: the values defined beside algorithm lines (this is used for 1-1 case when no boolean chain specified)
        self.values_source = &#34;algorithm&#34;
    else:
        # source №3: the values defined beside trace lines
        #  (this is less preferred as the trace may contain errors)
        self.values_source = &#34;trace&#34;


    def next_cond_value(expr_name=None, executes_id=None, n=None, default=False):

        i, _ = self.last_cond_tuple
        v = None

        if self.values_source == &#34;boolean_chain&#34;:
            v = next(self.condition_value_generator)
        else:
            assert n is not None, str(n)

            if self.values_source == &#34;algorithm&#34;:
                assert expr_name is not None, str(expr_name)
                expr_values_dict = self.data[&#34;algorithm&#34;][&#34;expr_values&#34;]
                if expr_name in expr_values_dict:
                    expr_values = expr_values_dict[expr_name]
                else:
                    raise ValueError(
                        f&#34;Algorithm processing error: No values of condition expression &#39;{expr_name}&#39; are provided.\nConsider example of how to specify values [true, true, false] for this condition as if it belongs to a loop:\n &lt;pre&gt;while {expr_name} -&gt; 110  // loop_name&lt;/pre&gt;&#34;)
                v = get_ith_expr_value(expr_values, i=n - 1)

            if self.values_source == &#34;trace&#34;:
                # find act with appropriate name and exec_time
                # (phase is defaulted to &#34;finished&#34; as values are attached to these only)
                assert expr_name is not None or executes_id is not None, str((expr_name, executes_id))
                acts = [
                    act for act in
                    find_by_keyval_in(&#34;n&#34;, str(n), self.data[&#34;trace&#34;])
                    # act[&#34;n&#34;] == n and
                    if act[&#34;phase&#34;] in (&#34;finished&#34;, &#39;performed&#39;)
                        and (act[&#34;executes&#34;] == executes_id)
                ]
                if acts:
                    assert len(acts) == 1, &#34;Expected 1 act to be found, but got:\n &#34; + str(acts)
                    act = acts[0]
                    v = act.get(&#34;value&#34;, None)
                else:
                    print(&#34;Warning: cannot find student_act: %s&#34; % (
                        dict(expr_name=expr_name, executes_id=executes_id, n=n)))

        if v is None:
            v = default
            print(&#34;next_cond_value(): defaulting to&#34;, default)
        self.last_cond_tuple = (i + 1, v)
        return v

    # long recursive function
    def make_correct_trace_for_alg_node(node):
        # copy reference
        result = self.data[&#34;correct_trace&#34;]

        if node[&#34;type&#34;] in {&#34;func&#34;}:

            phase = &#34;started&#34;
            ith = 1 + len([x for x in find_by_keyval_in(&#34;name&#34;, node[&#34;name&#34;], result) if x[&#34;phase&#34;] == phase])
            result.append({
                &#34;id&#34;: self.newID(),
                &#34;name&#34;: node[&#34;name&#34;],
                &#34;executes&#34;: node[&#34;body&#34;][&#34;id&#34;],
                &#34;phase&#34;: phase,
                &#34;n&#34;: ith,
                # &#34;text_line&#34;: None,
                # &#34;comment&#34;: None,
            })

            for body_node in node[&#34;body&#34;][&#34;body&#34;]:
                make_correct_trace_for_alg_node(body_node)

            if self.consequent_mode != &#34;normal&#34;:
                # return encountered
                self.consequent_mode = &#34;normal&#34;

            phase = &#34;finished&#34;
            ith = 1 + len([x for x in find_by_keyval_in(&#34;name&#34;, node[&#34;name&#34;], result) if x[&#34;phase&#34;] == phase])
            result.append({
                &#34;id&#34;: self.newID(),
                &#34;name&#34;: node[&#34;name&#34;],
                &#34;executes&#34;: node[&#34;body&#34;][&#34;id&#34;],
                &#34;phase&#34;: phase,
                &#34;n&#34;: ith,
                # &#34;text_line&#34;: None,
                # &#34;comment&#34;: None,
            })

        if node[&#34;type&#34;] in {&#34;sequence&#34;, &#34;else&#34;}:

            # do not wrap &#39;global_code&#39;
            if node[&#34;name&#34;] != &#39;global_code&#39;:
                phase = &#34;started&#34;
                ith = 1 + len([x for x in find_by_keyval_in(&#34;name&#34;, node[&#34;name&#34;], result) if x[&#34;phase&#34;] == phase])
                result.append({
                    &#34;id&#34;: self.newID(),
                    &#34;name&#34;: node[&#34;name&#34;],
                    &#34;executes&#34;: node[&#34;id&#34;],
                    &#34;phase&#34;: phase,
                    &#34;n&#34;: ith,
                    # &#34;text_line&#34;: None,
                    # &#34;comment&#34;: None,
                })

            for body_node in node[&#34;body&#34;]:
                make_correct_trace_for_alg_node(body_node)
                if self.consequent_mode != &#34;normal&#34;:
                    break

            # do not wrap &#39;global_code&#39;
            if node[&#34;name&#34;] != &#39;global_code&#39;:
                phase = &#34;finished&#34;
                ith = 1 + len([x for x in find_by_keyval_in(&#34;name&#34;, node[&#34;name&#34;], result) if x[&#34;phase&#34;] == phase])
                result.append({
                    &#34;id&#34;: self.newID(),
                    &#34;name&#34;: node[&#34;name&#34;],
                    &#34;executes&#34;: node[&#34;id&#34;],
                    &#34;phase&#34;: phase,
                    &#34;n&#34;: ith,
                    # &#34;text_line&#34;: None,
                    # &#34;comment&#34;: None,
                })

        if node[&#34;type&#34;] in {&#34;alternative&#34;}:

            phase = &#34;started&#34;
            ith = 1 + len([x for x in find_by_keyval_in(&#34;name&#34;, node[&#34;name&#34;], result) if x[&#34;phase&#34;] == phase])
            result.append({
                &#34;id&#34;: self.newID(),
                &#34;name&#34;: node[&#34;name&#34;],
                &#34;executes&#34;: node[&#34;id&#34;],
                &#34;phase&#34;: phase,
                &#34;n&#34;: ith,
                # &#34;text_line&#34;: None,
                # &#34;comment&#34;: None,
            })

            for branch in node[&#34;branches&#34;]:
                make_correct_trace_for_alg_node(branch)
                if self.last_cond_tuple[1] == True:
                    break
                if self.consequent_mode != &#34;normal&#34;:
                    break

            phase = &#34;finished&#34;
            ith = 1 + len([x for x in find_by_keyval_in(&#34;name&#34;, node[&#34;name&#34;], result) if x[&#34;phase&#34;] == phase])
            result.append({
                &#34;id&#34;: self.newID(),
                &#34;name&#34;: node[&#34;name&#34;],
                &#34;executes&#34;: node[&#34;id&#34;],
                &#34;phase&#34;: phase,
                &#34;n&#34;: ith,
                # &#34;text_line&#34;: None,
                # &#34;comment&#34;: None,
            })

        if node[&#34;type&#34;] in {&#34;if&#34;, &#34;else-if&#34;}:
            make_correct_trace_for_alg_node(node[&#34;cond&#34;])
            _, cond_v = self.last_cond_tuple
            if cond_v:
                phase = &#34;started&#34;
                ith = 1 + len([x for x in find_by_keyval_in(&#34;name&#34;, node[&#34;name&#34;], result) if x[&#34;phase&#34;] == phase])
                result.append({
                    &#34;id&#34;: self.newID(),
                    &#34;name&#34;: node[&#34;name&#34;],
                    &#34;executes&#34;: node[&#34;id&#34;],
                    &#34;phase&#34;: phase,
                    &#34;n&#34;: ith,
                    # &#34;text_line&#34;: None,
                    # &#34;comment&#34;: None,
                })

                for body_node in node[&#34;body&#34;]:
                    make_correct_trace_for_alg_node(body_node)
                    if self.consequent_mode != &#34;normal&#34;:
                        break

                phase = &#34;finished&#34;
                ith = 1 + len([x for x in find_by_keyval_in(&#34;name&#34;, node[&#34;name&#34;], result) if x[&#34;phase&#34;] == phase])
                result.append({
                    &#34;id&#34;: self.newID(),
                    &#34;name&#34;: node[&#34;name&#34;],
                    &#34;executes&#34;: node[&#34;id&#34;],
                    &#34;phase&#34;: phase,
                    &#34;n&#34;: ith,
                    # &#34;text_line&#34;: None,
                    # &#34;comment&#34;: None,
                })

        if node[&#34;type&#34;] in {&#34;expr&#34;}:
            phase = &#34;performed&#34;
            ith = 1 + len([x for x in find_by_keyval_in(&#34;name&#34;, node[&#34;name&#34;], result) if x[&#34;phase&#34;] == phase])
            value = next_cond_value(node[&#34;name&#34;], node[&#34;id&#34;], ith)
            self.expr_id2values[node[&#34;id&#34;]] = self.expr_id2values.get(node[&#34;id&#34;], []) + [value]
            result.append({
                &#34;id&#34;: self.newID(),
                &#34;name&#34;: node[&#34;name&#34;],
                &#34;value&#34;: value,
                &#34;executes&#34;: node[&#34;id&#34;],
                &#34;phase&#34;: phase,
                &#34;n&#34;: ith,
                # &#34;text_line&#34;: None,
                # &#34;comment&#34;: None,
            })

        if node[&#34;type&#34;] in {&#34;stmt&#34;, &#34;break&#34;, &#34;continue&#34;, &#34;return&#34;}:
            phase = &#34;performed&#34;
            ith = 1 + len([x for x in find_by_keyval_in(&#34;name&#34;, node[&#34;name&#34;], result) if x[&#34;phase&#34;] == phase])
            result.append({
                &#34;id&#34;: self.newID(),
                &#34;name&#34;: node[&#34;name&#34;],
                &#34;executes&#34;: node[&#34;id&#34;],
                &#34;phase&#34;: phase,
                &#34;n&#34;: ith,
                # &#34;text_line&#34;: None,
                # &#34;comment&#34;: None,
            })
            if node[&#34;type&#34;] in {&#34;break&#34;, &#34;continue&#34;, &#34;return&#34;}:
                self.consequent_mode = node[&#34;type&#34;]
                return  # just stupidly stop current sequence

        # TODO: keep list of loop classes up-to-date
        if node[&#34;type&#34;] in {&#34;while_loop&#34;, &#34;do_while_loop&#34;, &#34;do_until_loop&#34;, &#34;for_loop&#34;, &#34;foreach_loop&#34;,
                            &#34;infinite_loop&#34;, }:

            phase = &#34;started&#34;
            ith = 1 + len([x for x in find_by_keyval_in(&#34;name&#34;, node[&#34;name&#34;], result) if x[&#34;phase&#34;] == phase])
            result.append({
                &#34;id&#34;: self.newID(),
                &#34;name&#34;: node[&#34;name&#34;],
                &#34;executes&#34;: node[&#34;id&#34;],
                &#34;phase&#34;: phase,
                &#34;n&#34;: ith,
                # &#34;text_line&#34;: None,
                # &#34;comment&#34;: None,
            })

            inverse_cond = node[&#34;type&#34;] == &#34;do_until_loop&#34;
            stop_cond_value = True == inverse_cond

            def _loop_context():  # wrapper for return
                # loop begin
                if node[&#34;type&#34;] in {&#34;for_loop&#34;, &#34;foreach_loop&#34;}:
                    make_correct_trace_for_alg_node(node[&#34;init&#34;])

                if node[&#34;type&#34;] in {&#34;while_loop&#34;, &#34;for_loop&#34;, &#34;foreach_loop&#34;}:
                    make_correct_trace_for_alg_node(node[&#34;cond&#34;])
                    if self.last_cond_tuple[1] == stop_cond_value:
                        return

                # loop cycle
                while (True):

                    if node[&#34;type&#34;] in {&#34;foreach_loop&#34;}:
                        make_correct_trace_for_alg_node(node[&#34;update&#34;])

                    # a loop iteration!
                    make_correct_trace_for_alg_node(node[&#34;body&#34;])

                    if self.consequent_mode == &#34;continue&#34;:
                        # reset mode
                        self.consequent_mode = &#34;normal&#34;
                    elif self.consequent_mode == &#34;break&#34;:
                        # reset mode
                        self.consequent_mode = &#34;normal&#34;
                        return
                    elif self.consequent_mode != &#34;normal&#34;:
                        # return encountered
                        return

                    if node[&#34;type&#34;] in {&#34;for_loop&#34;}:
                        make_correct_trace_for_alg_node(node[&#34;update&#34;])

                    if node[&#34;type&#34;] not in {&#34;infinite_loop&#34;}:
                        make_correct_trace_for_alg_node(node[&#34;cond&#34;])
                        if self.last_cond_tuple[1] == stop_cond_value:
                            return

            _loop_context()  # make a loop

            phase = &#34;finished&#34;
            ith = 1 + len([x for x in find_by_keyval_in(&#34;name&#34;, node[&#34;name&#34;], result) if x[&#34;phase&#34;] == phase])
            result.append({
                &#34;id&#34;: self.newID(),
                &#34;name&#34;: node[&#34;name&#34;],
                &#34;executes&#34;: node[&#34;id&#34;],
                &#34;phase&#34;: phase,
                &#34;n&#34;: ith,
                # &#34;text_line&#34;: None,
                # &#34;comment&#34;: None,
            })

    alg_node = self.alg_entry()

    name = &#34;program&#34;
    phase = &#34;started&#34;
    self.data[&#34;correct_trace&#34;].append({
        &#34;id&#34;: self.newID(),
        &#34;name&#34;: name,
        &#34;executes&#34;: alg_node[&#34;id&#34;],
        &#34;phase&#34;: phase,
        &#34;n&#34;: 1,
        # &#34;text_line&#34;: None,
        # &#34;comment&#34;: None,
    })
    make_correct_trace_for_alg_node(alg_node)
    phase = &#34;finished&#34;
    self.data[&#34;correct_trace&#34;].append({
        &#34;id&#34;: self.newID(),
        &#34;name&#34;: name,
        &#34;executes&#34;: alg_node[&#34;id&#34;],
        &#34;phase&#34;: phase,
        &#34;n&#34;: 1,
        # &#34;text_line&#34;: None,
        # &#34;comment&#34;: None,
    })</code></pre>
</details>
</dd>
<dt id="ctrlstrct_run.TraceTester.newID"><code class="name flex">
<span>def <span class="ident">newID</span></span>(<span>self, what=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Increment and return new unused integer ID</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newID(self, what=None):
    &#34;&#34;&#34;Increment and return new unused integer ID&#34;&#34;&#34;
    while True:
        self._maxID += 1
        if self._maxID not in self.id2obj:
            break
    return self._maxID</code></pre>
</details>
</dd>
<dt id="ctrlstrct_run.TraceTester.prepare_act_candidates"><code class="name flex">
<span>def <span class="ident">prepare_act_candidates</span></span>(<span>self, onto)</span>
</code></dt>
<dd>
<div class="desc"><p>Create all required acts for each statement.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepare_act_candidates(self, onto):
    &#34;&#34;&#34;Create all required acts for each statement. &#34;&#34;&#34;

    alg_id2max_exec_n = {st_id: 0 for st_id in self.id2obj.keys()}  # executed stmt id to max exec_time of the act
    for act in self.data[&#34;correct_trace&#34;]:
        executed_id = act[&#34;executes&#34;]
        exec_n = act[&#34;n&#34;]
        alg_id2max_exec_n[executed_id] = exec_n  # assume &#34;n&#34;s appear consequently in the trace

    # ensure that student&#39;s acts exist
    for act in self.data[&#34;trace&#34;]:
        executed_id = act[&#34;executes&#34;]
        exec_n = act.get(&#34;n&#34;, &#34;1&#34;)
        alg_id2max_exec_n[executed_id] = max(
            int(exec_n),  # assume &#34;n&#34;s appear consequently in the trace
            int(alg_id2max_exec_n[executed_id]))

    entry_stmt_id = self.alg_entry()[&#34;id&#34;]

    max_act_ID = 1000

    def set_id(act_obj):
        nonlocal max_act_ID
        max_act_ID += 1
        make_triple(act_obj, onto.id, max_act_ID)

    # make top-level act representing the trace ...
    iri = f&#39;trace_{self.data[&#34;trace_name&#34;]}&#39;
    if self.data[&#34;header_boolean_chain&#34;]:
        iri += f&#39;_c{&#34;&#34;.join(map(str, map(int, self.data[&#34;header_boolean_chain&#34;])))}&#39;

    iri = iri.replace(&#34; &#34;, &#34;_&#34;).strip(&#34;_&#34;)

    iri = prepare_name(iri)
    iri = uniqualize_iri(onto, iri)
    trace_obj = onto.trace(iri)
    self.trace_obj = trace_obj  # remember for trace injection
    trace_obj.is_a.append(onto.correct_act)
    make_triple(trace_obj, onto.executes, onto[self.data[&#34;algorithm&#34;][&#34;iri&#34;]])
    set_id(trace_obj)
    make_triple(trace_obj, onto.index, 0)
    make_triple(trace_obj, onto.student_index, 0)
    make_triple(trace_obj, onto.exec_time, 0)  # set to 0 so next is 1
    make_triple(trace_obj, onto.depth, 0)  # set to 0 so next is 1
    make_triple(trace_obj, onto.in_trace, trace_obj)  # each act belongs to trace

    for st_id, max_n in alg_id2max_exec_n.items():

        alg_elem = self.id2obj[st_id]
        if alg_elem[&#34;type&#34;] in {&#34;algorithm&#34;}:
            continue

        # prepare data
        name = alg_elem.get(&#34;name&#34;, &#34;unkn&#34;)
        clean_name = prepare_name(name)

        mark2act_obj = {}  # executed stmt id to list of act iri&#39;s can be consequently used in trace

        for exec_n in range(1, max_n + 1):

            # make instances: act_begin, act_end
            number_mark = &#34;&#34; if max_n &lt;= 1 else (&#34;_n%02d&#34; % exec_n)
            iri_template = f&#34;%s_{clean_name}{number_mark}&#34;  # _i{index:02}

            for mark, class_, boundary_prop in [(&#34;b&#34;, onto.act_begin, onto.begin_of),
                                                (&#34;e&#34;, onto.act_end, onto.end_of)]:
                iri = iri_template % mark
                iri = uniqualize_iri(onto, iri)

                obj = class_(iri)

                boundary = get_relation_subject(boundary_prop, onto[alg_elem[&#34;iri&#34;]])
                make_triple(obj, onto.executes, boundary)

                set_id(obj)
                make_triple(obj, onto.exec_time, exec_n)
                make_triple(obj, onto.in_trace, trace_obj)

                # keep current value for next iteration
                mark2act_obj[mark] = obj

                # attach expr value: for act_end only!
                if mark == &#34;e&#34; and alg_elem[&#34;type&#34;] in (&#34;expr&#34;,):
                    values = self.expr_id2values[st_id] if st_id in self.expr_id2values else []
                    # if len(values) &lt;= exec_n:
                    if exec_n &lt;= len(values):
                        value = values[exec_n - 1]
                    else:
                        value = False
                        print(&#34;attach expr value: defaulting to False...&#34;)
                    make_triple(obj, onto.expr_value, value)</code></pre>
</details>
</dd>
<dt id="ctrlstrct_run.TraceTester.prepare_id2obj"><code class="name flex">
<span>def <span class="ident">prepare_id2obj</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Fill <code>self.id2obj</code> with direct references to algorithm objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepare_id2obj(self):
    &#34;&#34;&#34;Fill `self.id2obj` with direct references to algorithm objects &#34;&#34;&#34;
    alg_objects = list(find_by_type(self.data[&#34;algorithm&#34;]))
    if not self.id2obj:
        # fill it once
        for d in alg_objects:
            if &#34;id&#34; in d:
                self.id2obj[d[&#34;id&#34;]] = d
        # store to original algorithm dict
        self.data[&#34;algorithm&#34;][&#34;id2obj&#34;] = self.id2obj</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ctrlstrct_run.clear_ontology" href="#ctrlstrct_run.clear_ontology">clear_ontology</a></code></li>
<li><code><a title="ctrlstrct_run.create_ontology_tbox" href="#ctrlstrct_run.create_ontology_tbox">create_ontology_tbox</a></code></li>
<li><code><a title="ctrlstrct_run.extact_mistakes" href="#ctrlstrct_run.extact_mistakes">extact_mistakes</a></code></li>
<li><code><a title="ctrlstrct_run.find_by_type" href="#ctrlstrct_run.find_by_type">find_by_type</a></code></li>
<li><code><a title="ctrlstrct_run.init_persistent_structure" href="#ctrlstrct_run.init_persistent_structure">init_persistent_structure</a></code></li>
<li><code><a title="ctrlstrct_run.link_objects" href="#ctrlstrct_run.link_objects">link_objects</a></code></li>
<li><code><a title="ctrlstrct_run.make_trace_for_algorithm" href="#ctrlstrct_run.make_trace_for_algorithm">make_trace_for_algorithm</a></code></li>
<li><code><a title="ctrlstrct_run.prepare_name" href="#ctrlstrct_run.prepare_name">prepare_name</a></code></li>
<li><code><a title="ctrlstrct_run.process_algtraces" href="#ctrlstrct_run.process_algtraces">process_algtraces</a></code></li>
<li><code><a title="ctrlstrct_run.save_schema" href="#ctrlstrct_run.save_schema">save_schema</a></code></li>
<li><code><a title="ctrlstrct_run.uniqualize_iri" href="#ctrlstrct_run.uniqualize_iri">uniqualize_iri</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ctrlstrct_run.TraceTester" href="#ctrlstrct_run.TraceTester">TraceTester</a></code></h4>
<ul class="">
<li><code><a title="ctrlstrct_run.TraceTester.alg_entry" href="#ctrlstrct_run.TraceTester.alg_entry">alg_entry</a></code></li>
<li><code><a title="ctrlstrct_run.TraceTester.initial_repair_data" href="#ctrlstrct_run.TraceTester.initial_repair_data">initial_repair_data</a></code></li>
<li><code><a title="ctrlstrct_run.TraceTester.inject_algorithm_to_ontology" href="#ctrlstrct_run.TraceTester.inject_algorithm_to_ontology">inject_algorithm_to_ontology</a></code></li>
<li><code><a title="ctrlstrct_run.TraceTester.inject_to_ontology" href="#ctrlstrct_run.TraceTester.inject_to_ontology">inject_to_ontology</a></code></li>
<li><code><a title="ctrlstrct_run.TraceTester.inject_trace_to_ontology" href="#ctrlstrct_run.TraceTester.inject_trace_to_ontology">inject_trace_to_ontology</a></code></li>
<li><code><a title="ctrlstrct_run.TraceTester.make_correct_trace" href="#ctrlstrct_run.TraceTester.make_correct_trace">make_correct_trace</a></code></li>
<li><code><a title="ctrlstrct_run.TraceTester.newID" href="#ctrlstrct_run.TraceTester.newID">newID</a></code></li>
<li><code><a title="ctrlstrct_run.TraceTester.prepare_act_candidates" href="#ctrlstrct_run.TraceTester.prepare_act_candidates">prepare_act_candidates</a></code></li>
<li><code><a title="ctrlstrct_run.TraceTester.prepare_id2obj" href="#ctrlstrct_run.TraceTester.prepare_id2obj">prepare_id2obj</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>